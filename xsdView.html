<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XSD XML Editor (8 Languages Supported)</title>
    <style>
        /* --- CSS è®Šæ•¸å®šç¾© (æ ¸å¿ƒæ›è†šæ©Ÿåˆ¶) --- */
        :root {
            /* èƒŒæ™¯èˆ‡ä¸»è‰²èª¿ */
            --primary-start: #667eea;
            --primary-end: #764ba2;
            --primary-shadow: rgba(102, 126, 234, 0.4);
            --primary-border: #667eea;
            --bg-light: #f7f9fc;

            /* æŒ‰éˆ•é…è‰² */
            --btn-val-s: #11998e; --btn-val-e: #38ef7d; --btn-val-shadow: rgba(56, 239, 125, 0.4);
            --btn-exp-s: #f093fb; --btn-exp-e: #f5576c; --btn-exp-shadow: rgba(245, 87, 108, 0.4);
            --btn-clr-s: #ff9a9e; --btn-clr-e: #fecfef; --btn-clr-shadow: rgba(255, 154, 158, 0.4);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, var(--primary-start) 0%, var(--primary-end) 100%);
            min-height: 100vh;
            padding: 20px;
            transition: background 0.5s ease;
            display: flex; justify-content: center; align-items: flex-start;
        }

        .container {
            width: 95%; max-width: 100%; margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            display: flex; flex-direction: column;
            min-height: 85vh;
        }

        .header {
            background: linear-gradient(135deg, var(--primary-start) 0%, var(--primary-end) 100%);
            color: white; padding: 30px; text-align: center; transition: background 0.5s ease;
        }
        .header h1 { font-size: 2.5em; margin-bottom: 10px; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2); }

        .controls {
            padding: 20px; background: var(--bg-light); border-bottom: 2px solid #e0e7ff;
            display: flex; gap: 15px; flex-wrap: wrap; align-items: center;
        }

        .file-input-wrapper { position: relative; overflow: hidden; display: inline-block; }
        .file-input-wrapper input[type=file] { position: absolute; left: -9999px; }
        .file-input-label {
            background: linear-gradient(135deg, var(--primary-start) 0%, var(--primary-end) 100%);
            color: white; padding: 12px 25px; border-radius: 8px; cursor: pointer; transition: all 0.3s ease;
            display: inline-block; font-weight: 600; box-shadow: 0 4px 15px var(--primary-shadow);
        }
        .file-input-label:hover { transform: translateY(-2px); }

        .btn {
            color: white; border: none; padding: 12px 25px; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: 600; transition: all 0.3s ease;
        }
        .btn:hover:not(:disabled) { transform: translateY(-2px); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }

        .btn-validate { background: linear-gradient(135deg, var(--btn-val-s) 0%, var(--btn-val-e) 100%); box-shadow: 0 4px 15px var(--btn-val-shadow); }
        .btn-export { background: linear-gradient(135deg, var(--btn-exp-s) 0%, var(--btn-exp-e) 100%); box-shadow: 0 4px 15px var(--btn-exp-shadow); }
        .btn-clear { background: linear-gradient(135deg, var(--btn-clr-s) 0%, var(--btn-clr-e) 100%); box-shadow: 0 4px 15px var(--btn-clr-shadow); }

        .content { display: flex; gap: 20px; padding: 20px; min-height: 600px; flex-grow: 1; }
        .panel { background: white; border-radius: 12px; padding: 20px; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08); display: flex; flex-direction: column; }
        .panel:first-child { flex: 0 0 calc(65% - 10px); max-width: calc(65% - 10px); }
        .panel:last-child { flex: 0 0 calc(35% - 10px); max-width: calc(35% - 10px); }
        
        @media (max-width: 768px) {
            .content { flex-direction: column; }
            .panel:first-child, .panel:last-child { flex: 1 1 100%; max-width: 100%; }
        }
        
        .panel-header { display: flex; justify-content: space-between; align-items: center; padding-bottom: 10px; border-bottom: 2px solid var(--primary-border); }
        .panel-title { font-size: 1.3em; font-weight: 600; color: #333; margin-bottom: 0; }

        .view-toggle-btn { background: #f3f4f6; color: #6b7280; border: 2px solid #e5e7eb; padding: 8px 15px; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: 600; transition: all 0.2s; }
        .view-toggle-btn.active { background: linear-gradient(135deg, var(--primary-start) 0%, var(--primary-end) 100%); color: white; border-color: transparent; }

        .tree-view { font-family: 'Courier New', monospace; line-height: 1.8; overflow: auto; max-height: 700px; flex-grow: 1; }
        .tree-node { margin-left: 20px; position: relative; }
        .tree-node.root { margin-left: 0; }
        .node-header { display: flex; align-items: center; padding: 5px; border-radius: 5px; transition: background 0.2s; cursor: pointer; }
        .node-header:hover { background: rgba(0,0,0, 0.05); }
        .toggle-btn { width: 20px; height: 20px; margin-right: 8px; cursor: pointer; user-select: none; display: inline-flex; align-items: center; justify-content: center; background: var(--primary-start); color: white; border-radius: 3px; font-size: 12px; transition: transform 0.2s; }
        .toggle-btn.collapsed { background: #9ca3af; }
        .node-tag { color: #2563eb; font-weight: 600; }
        .node-attribute { color: #dc2626; margin-left: 10px; }
        .node-children { display: block; border-left: 2px solid #e5e7eb; margin-left: 10px; padding-left: 10px; }
        .node-children.collapsed { display: none; }
        .edit-input { border: 1px solid var(--primary-border); border-radius: 4px; padding: 2px 6px; font-family: inherit; font-size: inherit; color: #059669; background: rgba(255, 255, 255, 0.8); }
        .add-btn { margin-left: 10px; padding: 2px 8px; background: #10b981; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; transition: all 0.2s; }
        .add-btn:hover { background: #059669; transform: scale(1.05); }
        
        .xml-editor-container { position: relative; height: 700px; overflow: auto; border: 1px solid #e5e7eb; border-radius: 8px; margin-top: 15px; font-family: 'Courier New', monospace; font-size: 14px; line-height: 1.8; flex-grow: 1; }
        .line-numbers { float: left; width: 45px; height: 100%; background: #f7f9fc; color: #9ca3af; text-align: right; padding: 10px 10px 10px 0; border-right: 1px solid #e5e7eb; user-select: none; }
        #xmlRawInput { position: absolute; top: 0; left: 45px; width: calc(100% - 45px); height: 100%; border: none; outline: none; resize: none; padding: 10px; background: transparent; color: transparent; caret-color: #333; font-family: inherit; font-size: inherit; line-height: inherit; }
        #xmlHighlight { padding: 10px; white-space: pre; pointer-events: none; }
        .xml-tag { color: #2563eb; } .xml-attr-name { color: #9d174d; } .xml-attr-value { color: #dc2626; } .xml-content { color: #059669; }
        
        /* Modal Styles */
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); animation: fadeIn 0.3s; }
        .modal.show { display: block; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .modal-content { background: white; margin: 5% auto; padding: 0; border-radius: 12px; width: 600px; max-width: 90%; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3); animation: slideDown 0.3s; }
        @keyframes slideDown { from { transform: translateY(-50px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        .modal-header { background: linear-gradient(135deg, var(--primary-start) 0%, var(--primary-end) 100%); color: white; padding: 20px; border-radius: 12px 12px 0 0; display: flex; justify-content: space-between; align-items: center; }
        .modal-header h3 { margin: 0; font-size: 1.3em; }
        .close-modal { background: none; border: none; color: white; font-size: 28px; cursor: pointer; padding: 0; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; transition: transform 0.2s; }
        .close-modal:hover { transform: rotate(90deg); }
        .modal-body { padding: 20px; max-height: 60vh; overflow-y: auto; }
        .element-option { padding: 12px; margin: 8px 0; border: 2px solid #e5e7eb; border-radius: 8px; cursor: pointer; transition: all 0.2s; background: white; }
        .element-option:hover { border-color: var(--primary-border); background: var(--bg-light); transform: translateX(5px); }
        .element-option.selected { border-color: var(--primary-border); background: var(--bg-light); }
        .element-name { font-weight: 600; color: #2563eb; font-size: 1.1em; }
        .element-type { font-size: 0.9em; color: #6b7280; margin-top: 4px; }
        .element-constraints { font-size: 0.85em; color: #9ca3af; margin-top: 4px; }
        .modal-footer { padding: 15px 20px; border-top: 1px solid #e5e7eb; display: flex; gap: 10px; justify-content: flex-end; }
        .modal-btn { padding: 10px 20px; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; transition: all 0.2s; }
        .modal-btn.primary { background: linear-gradient(135deg, var(--primary-start) 0%, var(--primary-end) 100%); color: white; }
        .modal-btn.primary:hover { transform: translateY(-2px); box-shadow: 0 4px 12px var(--primary-shadow); }
        .modal-btn.secondary { background: #f3f4f6; color: #6b7280; }
        .modal-btn.secondary:hover { background: #e5e7eb; }
        .custom-input-section { margin-top: 20px; padding-top: 20px; border-top: 2px solid #e5e7eb; }
        .custom-input { width: 100%; padding: 10px; border: 2px solid #e5e7eb; border-radius: 6px; font-size: 1em; transition: border-color 0.2s; }
        .custom-input:focus { outline: none; border-color: var(--primary-border); }
        select.custom-input { appearance: none; background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e"); background-repeat: no-repeat; background-position: right 10px center; background-size: 1em; cursor: pointer; }
        .attribute-input-group { margin-top: 15px; padding: 10px; background: #f9fafb; border-radius: 6px; }
        .attribute-row { display: flex; gap: 10px; margin-bottom: 10px; }
        .attribute-row input { flex: 1; padding: 8px; border: 1px solid #e5e7eb; border-radius: 4px; }
        .attribute-row input:focus { border-color: var(--primary-border); outline: none; }
        .delete-btn { margin-left: 10px; padding: 2px 8px; background: #ef4444; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; transition: all 0.2s; }
        .validation-result { margin-top: 20px; padding: 15px; border-radius: 8px; font-weight: 500; animation: slideIn 0.3s ease; }
        @keyframes slideIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
        .validation-result.valid { background: linear-gradient(135deg, rgba(16, 185, 129, 0.1) 0%, rgba(5, 150, 105, 0.1) 100%); border: 2px solid #10b981; color: #059669; }
        .validation-result.invalid { background: linear-gradient(135deg, rgba(239, 68, 68, 0.1) 0%, rgba(220, 38, 38, 0.1) 100%); border: 2px solid #ef4444; color: #dc2626; }
        .status-bar { background: #f3f4f6; padding: 10px 20px; border-top: 1px solid #e5e7eb; display: flex; justify-content: space-between; align-items: center; font-size: 14px; color: #6b7280; }
        .loading { display: inline-block; width: 20px; height: 20px; border: 3px solid #f3f4f6; border-top: 3px solid var(--primary-start); border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .edit-btn { background: linear-gradient(135deg, #ffc107 0%, #ff9800 100%); }
        .attribute-option { padding: 8px; margin: 5px; border: 1px solid #e5e7eb; border-radius: 5px; cursor: pointer; display: inline-block; transition: all 0.2s; background: #f9fafb; font-size: 0.9em; }
        .attribute-option:hover { background: var(--bg-light); border-color: var(--primary-border); }
        .attribute-option.required { font-weight: bold; color: #dc2626; }
        .value-input-section { margin-top: 20px; }
        .select-box { padding: 12px; border-radius: 8px; border: 1px solid #e0e7ff; background: white; color: #555; font-weight: 600; cursor: pointer; outline: none; box-shadow: 0 4px 15px rgba(0,0,0,0.05); transition: border-color 0.3s; }
        .select-box:hover { border-color: var(--primary-border); }
        .footer { background: #f8fafc; padding: 15px; text-align: center; font-size: 13px; color: #64748b; border-top: 1px solid #e2e8f0; display: flex; justify-content: center; gap: 15px; align-items: center; }
        .footer-link { display: flex; align-items: center; gap: 6px; color: var(--primary-start); text-decoration: none; font-weight: 600; transition: color 0.3s ease; }
        .footer-link:hover { color: var(--primary-end); text-decoration: underline; }
        .separator { color: #cbd5e1; }

        /* --- æ¨™ç±¤èˆ‡ XPath æ¨£å¼ --- */
        .constraints-container { margin-top: 5px; display: flex; flex-wrap: wrap; gap: 5px; margin-left: 24px; }
        .constraint-badge { font-size: 0.75em; padding: 2px 6px; border-radius: 4px; font-family: 'Consolas', monospace; display: inline-flex; align-items: center; gap: 4px; }
        .badge-count { background: #e0f2fe; color: #0284c7; border: 1px solid #bae6fd; }
        .badge-pattern { background: #f3e8ff; color: #9333ea; border: 1px solid #e9d5ff; }
        .badge-number { background: #ffedd5; color: #ea580c; border: 1px solid #fed7aa; }
        .badge-length { background: #dcfce7; color: #16a34a; border: 1px solid #bbf7d0; }
        .badge-complex { background: #e2e8f0; color: #475569; border: 1px solid #cbd5e1; font-weight: bold; }
        .badge-simple { background: #f0fdf4; color: #15803d; border: 1px solid #bbf7d0; font-weight: bold; }
        
        /* XPath Badge */
        .badge-xpath { 
            background: #2d3748; color: #e2e8f0; border: 1px solid #1a202c; font-family: 'Consolas', 'Monaco', monospace; font-size: 0.8em; width: 100%; display: block; margin-top: 6px; padding: 6px 10px; border-radius: 6px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }
        .badge-xpath:before { content: "XPath: "; color: #718096; margin-right: 5px; font-weight: normal; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 data-i18n="app_title">ğŸ”§ XSD-based XML Editor</h1>
            <p data-i18n="app_subtitle">è¼‰å…¥XSDæ¶æ§‹ï¼Œç·¨è¼¯ä¸¦é©—è­‰æ‚¨çš„XMLæ–‡ä»¶</p>
        </div>
        <div class="controls">
            <div class="file-input-wrapper">
                <input type="file" id="xsdFile" accept=".xsd">
                <label for="xsdFile" class="file-input-label" data-i18n="btn_load_xsd">ğŸ“ è¼‰å…¥ XSD æª”æ¡ˆ</label>
            </div>
            
            <button class="btn btn-validate" onclick="validateXML()" id="validateBtn" disabled data-i18n="btn_validate">âœ“ é©—è­‰ XML</button>
            <button class="btn btn-export" onclick="exportXML()" data-i18n="btn_export">ğŸ’¾ åŒ¯å‡º XML</button>
            <button class="btn btn-clear" onclick="clearAll()" data-i18n="btn_clear">ğŸ—‘ï¸ æ¸…é™¤å…¨éƒ¨</button>
            
            <select id="langSelect" class="select-box" onchange="changeLanguage(this.value)">
                <option value="en">English</option>
                <option value="ja">æ—¥æœ¬èª</option>
                <option value="zh-TW">ç¹é«”ä¸­æ–‡</option>
                <option value="zh-CN">ç®€ä½“ä¸­æ–‡</option>
                <option value="th">à¸ à¸²à¸©à¸²à¹„à¸—à¸¢</option>
                <option value="ko">í•œêµ­ì–´</option>
                <option value="fr">FranÃ§ais</option>
                <option value="de">Deutsch</option>
            </select>

            <select id="themeSelect" class="select-box" onchange="changeTheme(this.value)">
                <option value="default" data-i18n="theme_default">é è¨­ä¸»é¡Œ</option>
                <option value="morandi-red" data-i18n="theme_red">è«è˜­è¿ªç´…</option>
                <option value="morandi-yellow" data-i18n="theme_yellow">è«è˜­è¿ªé»ƒ</option>
                <option value="morandi-blue" data-i18n="theme_blue">è«è˜­è¿ªè—</option>
                <option value="morandi-green" data-i18n="theme_green">è«è˜­è¿ªç¶ </option>
                <option value="morandi-pink" data-i18n="theme_pink">è«è˜­è¿ªç²‰</option>
            </select>
        </div>
        <div class="content">
            <div class="panel">
                <div class="panel-header">
                     <h2 class="panel-title" data-i18n="panel_xml_editor">XML ç·¨è¼¯å™¨</h2>
                     <div>
                        <button id="showTreeViewBtn" class="view-toggle-btn active" onclick="switchToTreeView()" data-i18n="view_tree">æ¨¹ç‹€ç·¨è¼¯å™¨</button>
                        <button id="showXmlViewBtn" class="view-toggle-btn" onclick="switchToXmlView()" data-i18n="view_source">XML åŸå§‹ç¢¼</button>
                     </div>
                </div>
                <div id="treeView" class="tree-view" style="margin-top: 15px;">
                    <p style="color: #9ca3af; text-align: center; padding: 50px;" data-i18n="msg_load_xsd_first">è«‹å…ˆè¼‰å…¥ XSD æª”æ¡ˆä»¥é–‹å§‹ç·¨è¼¯</p>
                </div>
                <div id="xmlEditorContainer" class="xml-editor-container" style="display: none;">
                    <div class="line-numbers" id="lineNumbers">1</div>
                    <div style="margin-left: 45px; position: relative;">
                        <pre id="xmlHighlight" aria-hidden="true"><code></code></pre>
                        <textarea id="xmlRawInput" wrap="off" spellcheck="false"></textarea>
                    </div>
                </div>
            </div>
            <div class="panel">
                <div class="panel-header">
                    <h2 class="panel-title" data-i18n="panel_xsd_info">XSD æ¶æ§‹è³‡è¨Š</h2>
                </div>
                <div id="validationResult"></div>
                <div id="schemaInfo" style="color: #6b7280; margin-top: 15px;"><p data-i18n="msg_no_schema">å°šæœªè¼‰å…¥æ¶æ§‹</p></div>
            </div>
        </div>
        <div class="status-bar">
            <span id="statusText" data-i18n="status_ready">å°±ç·’</span>
            <span id="nodeCount" data-i18n="status_nodes">ç¯€é»æ•¸: 0</span>
        </div>
        <div class="footer">
            <a href="https://github.com/bluemoney/XSDBasedXMLEditor" target="_blank" class="footer-link">
                <svg height="20" width="20" viewBox="0 0 16 16" fill="currentColor">
                    <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
                </svg>
                XSDBasedXMLEditor
            </a>
            <span class="separator">|</span>
            <span>Apache-2.0 License</span>
        </div>
    </div>

    <div id="elementModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="modalTitle">é¸æ“‡è¦æ–°å¢çš„å…ƒç´ </h3>
                <button class="close-modal" onclick="closeElementModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div id="elementOptions"></div>
                <div class="custom-input-section">
                    <h4 data-i18n="label_custom_elem">è‡ªè¨‚å…ƒç´ </h4>
                    <input type="text" class="custom-input" id="customElementName" placeholder="è¼¸å…¥è‡ªè¨‚å…ƒç´ åç¨±" readonly style="background: #f3f4f6;">
                    
                    <div id="valueInputSection" class="value-input-section" style="display: none;">
                        <h4 data-i18n="label_node_value">ç¯€é»å€¼</h4>
                        <input type="text" class="custom-input" id="elementValueInput" placeholder="è¼¸å…¥ç¯€é»å€¼">
                        <select id="elementValueSelect" class="custom-input" style="display: none;"></select>
                        <input type="date" class="custom-input" id="elementValueDate" style="display: none;">
                        <input type="datetime-local" class="custom-input" id="elementValueDateTime" style="display: none;">
                        <input type="time" step="1" class="custom-input" id="elementValueTime" style="display: none;">
                        
                        <small id="enumHint" style="display: none; color: #667eea; margin-top: 5px;" data-i18n="hint_enum">âœ¨ å·²å¾ XSD è¼‰å…¥é¸é …</small>
                        <small id="dateHint" style="display: none; color: #667eea; margin-top: 5px;" data-i18n="hint_date">ğŸ“… è«‹é¸æ“‡æ—¥æœŸ</small>
                        <small id="dateTimeHint" style="display: none; color: #667eea; margin-top: 5px;" data-i18n="hint_datetime">ğŸ“… è«‹é¸æ“‡æ—¥æœŸèˆ‡æ™‚é–“</small>
                        <small id="timeHint" style="display: none; color: #667eea; margin-top: 5px;" data-i18n="hint_time">â° è«‹é¸æ“‡æ™‚é–“</small>
                    </div>

                    <div class="attribute-input-group">
                        <h5 style="margin: 0 0 10px 0; color: #6b7280; font-size: 0.9em;" data-i18n="label_attrs">å±¬æ€§ (é¸å¡«)</h5>
                        <div id="attributeOptions"></div>
                        <div id="attributeInputs"></div>
                        <button class="add-btn" onclick="addAttributeRow()" style="margin-top: 5px;" data-i18n="btn_add_attr">+ æ–°å¢å±¬æ€§</button>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn secondary" onclick="closeElementModal()" data-i18n="btn_cancel">å–æ¶ˆ</button>
                <button class="modal-btn primary" onclick="confirmAction()" data-i18n="btn_confirm">ç¢ºèªæ–°å¢</button>
            </div>
        </div>
    </div>

    <script>
        let xsdDoc = null;
        let xmlDoc = null;
        let nodeIdCounter = 0;
        let xsdElements = new Map();
        let currentParentNode = null;
        let currentNodeToModify = null;
        
        // --- Theme Configurations ---
        const themes = {
            "default": { start: "#667eea", end: "#764ba2", shadow: "rgba(102, 126, 234, 0.4)", border: "#667eea", btnValS: "#11998e", btnValE: "#38ef7d", btnValShadow: "rgba(56, 239, 125, 0.4)", btnExpS: "#f093fb", btnExpE: "#f5576c", btnExpShadow: "rgba(245, 87, 108, 0.4)", btnClrS: "#ff9a9e", btnClrE: "#fecfef", btnClrShadow: "rgba(255, 154, 158, 0.4)" },
            "morandi-red": { start: "#d6a2a2", end: "#bf7e7e", shadow: "rgba(191, 126, 126, 0.4)", border: "#bf7e7e", btnValS: "#bf7e7e", btnValE: "#a66b6b", btnValShadow: "rgba(166, 107, 107, 0.4)", btnExpS: "#d6a2a2", btnExpE: "#e0b0b0", btnExpShadow: "rgba(214, 162, 162, 0.4)", btnClrS: "#e8d5d5", btnClrE: "#f2e6e6", btnClrShadow: "rgba(232, 213, 213, 0.4)" },
            "morandi-yellow": { start: "#e3cda4", end: "#c7ad7f", shadow: "rgba(199, 173, 127, 0.4)", border: "#c7ad7f", btnValS: "#c7ad7f", btnValE: "#b09569", btnValShadow: "rgba(176, 149, 105, 0.4)", btnExpS: "#e3cda4", btnExpE: "#eddcc0", btnExpShadow: "rgba(227, 205, 164, 0.4)", btnClrS: "#f5ece2", btnClrE: "#fcf8f5", btnClrShadow: "rgba(245, 236, 226, 0.4)" },
            "morandi-blue": { start: "#a6bace", end: "#7da0c2", shadow: "rgba(125, 160, 194, 0.4)", border: "#7da0c2", btnValS: "#7da0c2", btnValE: "#6389ad", btnValShadow: "rgba(99, 137, 173, 0.4)", btnExpS: "#a6bace", btnExpE: "#c2d1e0", btnExpShadow: "rgba(166, 186, 206, 0.4)", btnClrS: "#dce5ed", btnClrE: "#eef3f7", btnClrShadow: "rgba(220, 229, 237, 0.4)" },
            "morandi-green": { start: "#a9bea3", end: "#869e7e", shadow: "rgba(134, 158, 126, 0.4)", border: "#869e7e", btnValS: "#869e7e", btnValE: "#6d8566", btnValShadow: "rgba(109, 133, 102, 0.4)", btnExpS: "#a9bea3", btnExpE: "#c3d1be", btnExpShadow: "rgba(169, 190, 163, 0.4)", btnClrS: "#e1e8df", btnClrE: "#f0f4ef", btnClrShadow: "rgba(225, 232, 223, 0.4)" },
            "morandi-pink": { start: "#e0babe", end: "#c99399", shadow: "rgba(201, 147, 153, 0.4)", border: "#c99399", btnValS: "#c99399", btnValE: "#b07a81", btnValShadow: "rgba(176, 122, 129, 0.4)", btnExpS: "#e0babe", btnExpE: "#ebd2d5", btnExpShadow: "rgba(224, 186, 190, 0.4)", btnClrS: "#f5e6e8", btnClrE: "#fcf2f3", btnClrShadow: "rgba(245, 230, 232, 0.4)" }
        };

        function changeTheme(themeName) {
            const theme = themes[themeName] || themes['default'];
            const root = document.documentElement;
            root.style.setProperty('--primary-start', theme.start); root.style.setProperty('--primary-end', theme.end);
            root.style.setProperty('--primary-shadow', theme.shadow); root.style.setProperty('--primary-border', theme.border);
            root.style.setProperty('--btn-val-s', theme.btnValS); root.style.setProperty('--btn-val-e', theme.btnValE); root.style.setProperty('--btn-val-shadow', theme.btnValShadow);
            root.style.setProperty('--btn-exp-s', theme.btnExpS); root.style.setProperty('--btn-exp-e', theme.btnExpE); root.style.setProperty('--btn-exp-shadow', theme.btnExpShadow);
            root.style.setProperty('--btn-clr-s', theme.btnClrS); root.style.setProperty('--btn-clr-e', theme.btnClrE); root.style.setProperty('--btn-clr-shadow', theme.btnClrShadow);
        }

        // --- Translation Dictionary (Extended) ---
        const translations = {
            "en": { "app_title": "ğŸ”§ XSD-based XML Editor", "app_subtitle": "Load XSD schema, edit and validate your XML documents", "btn_load_xsd": "ğŸ“ Load XSD File", "btn_validate": "âœ“ Validate XML", "btn_export": "ğŸ’¾ Export XML", "btn_clear": "ğŸ—‘ï¸ Clear All", "panel_xml_editor": "XML Editor", "view_tree": "Tree Editor", "view_source": "XML Source", "msg_load_xsd_first": "Please load XSD file to start editing", "panel_xsd_info": "XSD Schema Info", "msg_no_schema": "No schema loaded", "status_ready": "Ready", "status_nodes": "Nodes: 0", "modal_title_add": "Select Element to Add", "modal_title_edit": "Edit Element", "label_custom_elem": "Selected Element", "label_node_value": "Node Value", "label_attrs": "Attributes (Optional)", "btn_add_attr": "+ Add Attribute", "btn_cancel": "Cancel", "btn_confirm": "Confirm", "hint_enum": "âœ¨ Options loaded from XSD", "hint_date": "ğŸ“… Select Date", "hint_datetime": "ğŸ“… Select Date & Time", "hint_time": "â° Select Time", "ph_attr_name": "Attr Name", "ph_attr_val": "Value", "btn_delete": "Delete", "btn_add_child": "+ Child", "btn_modify": "Edit", "xsd_loaded": "XSD Schema Loaded", "load_fail": "Failed to load XSD: ", "invalid_xsd": "Invalid XSD File", "val_updated": "Value updated", "confirm_del": "Delete this node?", "node_deleted": "Node deleted", "validating": "Validating...", "valid_pass": "âœ… XML is valid according to XSD!", "valid_pass_desc": "â€¢ All required elements present<br>â€¢ Structure matches schema<br>â€¢ Attributes are correct", "valid_fail": "âŒ XML is invalid", "valid_fail_desc": "<strong>Found issues:</strong>", "root_err": "Root element not defined in schema", "missing_attr": "Missing required attribute", "type_err": "Value mismatch for type", "enum_err": "Value not in allowed options", "missing_child": "Missing required child", "max_occurs_err": "Max occurs exceeded", "invalid_child": "Invalid child element", "no_xml_export": "No XML to export", "xml_exported": "XML Exported", "confirm_clear": "Clear all content?", "cleared": "All content cleared", "schema_elems": "Schema Elements:", "total_defs": "Total definitions", "no_child_defs": "No child elements defined in XSD", "opt_complex": "Complex Type", "opt_select": "-- Select --", "optional_attrs": "Optional Attributes", "err_invalid_name": "Please enter valid element name", "err_invalid_type": "Value does not match type", "theme_default": "Default", "theme_red": "Morandi Red", "theme_yellow": "Morandi Yellow", "theme_blue": "Morandi Blue", "theme_green": "Morandi Green", "theme_pink": "Morandi Pink" },
            "zh-TW": { "app_title": "ğŸ”§ XSD-based XML Editor", "app_subtitle": "è¼‰å…¥XSDæ¶æ§‹ï¼Œç·¨è¼¯ä¸¦é©—è­‰æ‚¨çš„XMLæ–‡ä»¶", "btn_load_xsd": "ğŸ“ è¼‰å…¥ XSD æª”æ¡ˆ", "btn_validate": "âœ“ é©—è­‰ XML", "btn_export": "ğŸ’¾ åŒ¯å‡º XML", "btn_clear": "ğŸ—‘ï¸ æ¸…é™¤å…¨éƒ¨", "panel_xml_editor": "XML ç·¨è¼¯å™¨", "view_tree": "æ¨¹ç‹€ç·¨è¼¯å™¨", "view_source": "XML åŸå§‹ç¢¼", "msg_load_xsd_first": "è«‹å…ˆè¼‰å…¥ XSD æª”æ¡ˆä»¥é–‹å§‹ç·¨è¼¯", "panel_xsd_info": "XSD æ¶æ§‹è³‡è¨Š", "msg_no_schema": "å°šæœªè¼‰å…¥æ¶æ§‹", "status_ready": "å°±ç·’", "status_nodes": "ç¯€é»æ•¸: 0", "modal_title_add": "é¸æ“‡è¦æ–°å¢çš„å…ƒç´ ", "modal_title_edit": "ä¿®æ”¹ç¾æœ‰å…ƒç´ ", "label_custom_elem": "è‡ªè¨‚å…ƒç´ ", "label_node_value": "ç¯€é»å€¼", "label_attrs": "å±¬æ€§ (é¸å¡«)", "btn_add_attr": "+ æ–°å¢å±¬æ€§", "btn_cancel": "å–æ¶ˆ", "btn_confirm": "ç¢ºèª", "hint_enum": "âœ¨ å·²å¾ XSD è¼‰å…¥é¸é …", "hint_date": "ğŸ“… è«‹é¸æ“‡æ—¥æœŸ", "hint_datetime": "ğŸ“… è«‹é¸æ“‡æ—¥æœŸèˆ‡æ™‚é–“", "hint_time": "â° è«‹é¸æ“‡æ™‚é–“", "ph_attr_name": "å±¬æ€§åç¨±", "ph_attr_val": "å±¬æ€§å€¼", "btn_delete": "åˆªé™¤", "btn_add_child": "+ å­ç¯€é»", "btn_modify": "ä¿®æ”¹", "xsd_loaded": "XSD æ¶æ§‹è¼‰å…¥æˆåŠŸ", "load_fail": "è¼‰å…¥ XSD å¤±æ•—: ", "invalid_xsd": "ç„¡æ•ˆçš„ XSD æª”æ¡ˆ", "val_updated": "ç¯€é»å€¼å·²æ›´æ–°", "confirm_del": "ç¢ºå®šè¦åˆªé™¤æ­¤ç¯€é»å—ï¼Ÿ", "node_deleted": "ç¯€é»å·²åˆªé™¤", "validating": "é©—è­‰ä¸­...", "valid_pass": "âœ… XML æ–‡ä»¶å®Œå…¨ç¬¦åˆ XSD æ¶æ§‹è¦ç¯„ï¼", "valid_pass_desc": "â€¢ æ‰€æœ‰å¿…è¦å…ƒç´ éƒ½å·²å­˜åœ¨<br>â€¢ å…ƒç´ çµæ§‹ç¬¦åˆæ¶æ§‹å®šç¾©<br>â€¢ å±¬æ€§è¨­å®šæ­£ç¢º", "valid_fail": "âŒ XML æ–‡ä»¶ä¸ç¬¦åˆ XSD æ¶æ§‹è¦ç¯„", "valid_fail_desc": "<strong>ç™¼ç¾ä»¥ä¸‹å•é¡Œï¼š</strong>", "root_err": "æ ¹å…ƒç´ æœªåœ¨æ¶æ§‹ä¸­å®šç¾©", "missing_attr": "ç¼ºå°‘å¿…è¦å±¬æ€§", "type_err": "å€¼ä¸ç¬¦åˆé¡å‹", "enum_err": "å€¼ä¸åœ¨å…è¨±çš„é¸é …ä¸­", "missing_child": "ç¼ºå°‘å¿…è¦çš„å­å…ƒç´ ", "max_occurs_err": "å‡ºç¾æ¬¡æ•¸è¶…éé™åˆ¶", "invalid_child": "ä¸æ˜¯æœ‰æ•ˆçš„å­å…ƒç´ ", "no_xml_export": "æ²’æœ‰å¯åŒ¯å‡ºçš„ XML æ–‡ä»¶", "xml_exported": "XML å·²åŒ¯å‡º", "confirm_clear": "ç¢ºå®šè¦æ¸…é™¤æ‰€æœ‰å…§å®¹å—ï¼Ÿ", "cleared": "å·²æ¸…é™¤æ‰€æœ‰å…§å®¹", "schema_elems": "æ¶æ§‹å…ƒç´ :", "total_defs": "ç¸½å…±å®šç¾©æ•¸", "no_child_defs": "æ­¤å…ƒç´ æ²’æœ‰åœ¨XSDä¸­å®šç¾©çš„å­å…ƒç´ ", "opt_complex": "è¤‡åˆé¡å‹", "opt_select": "-- è«‹é¸æ“‡ --", "optional_attrs": "å¯é¸å±¬æ€§", "err_invalid_name": "è«‹è¼¸å…¥æœ‰æ•ˆçš„å…ƒç´ åç¨±", "err_invalid_type": "å€¼ä¸ç¬¦åˆ XSD é¡å‹", "theme_default": "é è¨­ä¸»é¡Œ", "theme_red": "è«è˜­è¿ªç´…", "theme_yellow": "è«è˜­è¿ªé»ƒ", "theme_blue": "è«è˜­è¿ªè—", "theme_green": "è«è˜­è¿ªç¶ ", "theme_pink": "è«è˜­è¿ªç²‰" },
            "zh-CN": { "app_title": "ğŸ”§ XSD-based XML Editor", "app_subtitle": "åŠ è½½XSDæ¶æ„ï¼Œç¼–è¾‘å¹¶éªŒè¯æ‚¨çš„XMLæ–‡æ¡£", "btn_load_xsd": "ğŸ“ åŠ è½½ XSD æ–‡ä»¶", "btn_validate": "âœ“ éªŒè¯ XML", "btn_export": "ğŸ’¾ å¯¼å‡º XML", "btn_clear": "ğŸ—‘ï¸ æ¸…é™¤å…¨éƒ¨", "panel_xml_editor": "XML ç¼–è¾‘å™¨", "view_tree": "æ ‘çŠ¶ç¼–è¾‘å™¨", "view_source": "XML æºç ", "msg_load_xsd_first": "è¯·å…ˆåŠ è½½ XSD æ–‡ä»¶ä»¥å¼€å§‹ç¼–è¾‘", "panel_xsd_info": "XSD æ¶æ„ä¿¡æ¯", "msg_no_schema": "å°šæœªåŠ è½½æ¶æ„", "status_ready": "å°±ç»ª", "status_nodes": "èŠ‚ç‚¹æ•°: 0", "modal_title_add": "é€‰æ‹©è¦æ–°å¢çš„å…ƒç´ ", "modal_title_edit": "ä¿®æ”¹ç°æœ‰å…ƒç´ ", "label_custom_elem": "è‡ªå®šä¹‰å…ƒç´ ", "label_node_value": "èŠ‚ç‚¹å€¼", "label_attrs": "å±æ€§ (é€‰å¡«)", "btn_add_attr": "+ æ–°å¢å±æ€§", "btn_cancel": "å–æ¶ˆ", "btn_confirm": "ç¡®è®¤", "hint_enum": "âœ¨ å·²ä» XSD åŠ è½½é€‰é¡¹", "hint_date": "ğŸ“… è¯·é€‰æ‹©æ—¥æœŸ", "hint_datetime": "ğŸ“… è¯·é€‰æ‹©æ—¥æœŸä¸æ—¶é—´", "hint_time": "â° è¯·é€‰æ‹©æ—¶é—´", "ph_attr_name": "å±æ€§åç§°", "ph_attr_val": "å±æ€§å€¼", "btn_delete": "åˆ é™¤", "btn_add_child": "+ å­èŠ‚ç‚¹", "btn_modify": "ä¿®æ”¹", "xsd_loaded": "XSD æ¶æ„åŠ è½½æˆåŠŸ", "load_fail": "åŠ è½½ XSD å¤±è´¥: ", "invalid_xsd": "æ— æ•ˆçš„ XSD æ–‡ä»¶", "val_updated": "èŠ‚ç‚¹å€¼å·²æ›´æ–°", "confirm_del": "ç¡®å®šè¦åˆ é™¤æ­¤èŠ‚ç‚¹å—ï¼Ÿ", "node_deleted": "èŠ‚ç‚¹å·²åˆ é™¤", "validating": "éªŒè¯ä¸­...", "valid_pass": "âœ… XML æ–‡æ¡£å®Œå…¨ç¬¦åˆ XSD æ¶æ„è§„èŒƒï¼", "valid_pass_desc": "â€¢ æ‰€æœ‰å¿…è¦å…ƒç´ éƒ½å·²å­˜åœ¨<br>â€¢ å…ƒç´ ç»“æ„ç¬¦åˆæ¶æ„å®šä¹‰<br>â€¢ å±æ€§è®¾ç½®æ­£ç¡®", "valid_fail": "âŒ XML æ–‡æ¡£ä¸ç¬¦åˆ XSD æ¶æ„è§„èŒƒ", "valid_fail_desc": "<strong>å‘ç°ä»¥ä¸‹é—®é¢˜ï¼š</strong>", "root_err": "æ ¹å…ƒç´ æœªåœ¨æ¶æ„ä¸­å®šä¹‰", "missing_attr": "ç¼ºå°‘å¿…è¦å±æ€§", "type_err": "å€¼ä¸ç¬¦åˆç±»å‹", "enum_err": "å€¼ä¸åœ¨å…è®¸çš„é€‰é¡¹ä¸­", "missing_child": "ç¼ºå°‘å¿…è¦çš„å­å…ƒç´ ", "max_occurs_err": "å‡ºç°æ¬¡æ•°è¶…è¿‡é™åˆ¶", "invalid_child": "ä¸æ˜¯æœ‰æ•ˆçš„å­å…ƒç´ ", "no_xml_export": "æ²¡æœ‰å¯å¯¼å‡ºçš„ XML æ–‡æ¡£", "xml_exported": "XML å·²å¯¼å‡º", "confirm_clear": "ç¡®å®šè¦æ¸…é™¤æ‰€æœ‰å†…å®¹å—ï¼Ÿ", "cleared": "å·²æ¸…é™¤æ‰€æœ‰å†…å®¹", "schema_elems": "æ¶æ„å…ƒç´ :", "total_defs": "æ€»å…±å®šä¹‰æ•°", "no_child_defs": "æ­¤å…ƒç´ æ²¡æœ‰åœ¨XSDä¸­å®šä¹‰çš„å­å…ƒç´ ", "opt_complex": "å¤åˆç±»å‹", "opt_select": "-- è¯·é€‰æ‹© --", "optional_attrs": "å¯é€‰å±æ€§", "err_invalid_name": "è¯·è¾“å…¥æœ‰æ•ˆçš„å…ƒç´ åç§°", "err_invalid_type": "å€¼ä¸ç¬¦åˆ XSD ç±»å‹", "theme_default": "é»˜è®¤ä¸»é¢˜", "theme_red": "è«å…°è¿ªçº¢", "theme_yellow": "è«å…°è¿ªé»„", "theme_blue": "è«å…°è¿ªè“", "theme_green": "è«å…°è¿ªç»¿", "theme_pink": "è«å…°è¿ªç²‰" },
            "ja": { "app_title": "ğŸ”§ XSD-based XML Editor", "app_subtitle": "XSDã‚¹ã‚­ãƒ¼ãƒã‚’èª­ã¿è¾¼ã¿ã€XMLã‚’ç·¨é›†ãƒ»æ¤œè¨¼ã—ã¾ã™", "btn_load_xsd": "ğŸ“ XSDã‚’èª­ã¿è¾¼ã‚€", "btn_validate": "âœ“ æ¤œè¨¼", "btn_export": "ğŸ’¾ ä¿å­˜", "btn_clear": "ğŸ—‘ï¸ å…¨ã¦æ¶ˆå»", "panel_xml_editor": "XMLã‚¨ãƒ‡ã‚£ã‚¿", "view_tree": "ãƒ„ãƒªãƒ¼è¡¨ç¤º", "view_source": "ã‚½ãƒ¼ã‚¹è¡¨ç¤º", "msg_load_xsd_first": "XSDãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„", "panel_xsd_info": "ã‚¹ã‚­ãƒ¼ãƒæƒ…å ±", "msg_no_schema": "ã‚¹ã‚­ãƒ¼ãƒãªã—", "status_ready": "æº–å‚™å®Œäº†", "status_nodes": "ãƒãƒ¼ãƒ‰æ•°: 0", "modal_title_add": "è¦ç´ ã®è¿½åŠ ", "modal_title_edit": "è¦ç´ ã®ç·¨é›†", "label_custom_elem": "è¦ç´ å", "label_node_value": "å€¤", "label_attrs": "å±æ€§ (ä»»æ„)", "btn_add_attr": "+ å±æ€§è¿½åŠ ", "btn_cancel": "ã‚­ãƒ£ãƒ³ã‚»ãƒ«", "btn_confirm": "æ±ºå®š", "hint_enum": "âœ¨ é¸æŠè‚¢ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ", "hint_date": "ğŸ“… æ—¥ä»˜ã‚’é¸æŠ", "hint_datetime": "ğŸ“… æ—¥æ™‚ã‚’é¸æŠ", "hint_time": "â° æ™‚é–“ã‚’é¸æŠ", "ph_attr_name": "å±æ€§å", "ph_attr_val": "å€¤", "btn_delete": "å‰Šé™¤", "btn_add_child": "+ å­è¦ç´ ", "btn_modify": "ç·¨é›†", "xsd_loaded": "XSDèª­ã¿è¾¼ã¿å®Œäº†", "load_fail": "èª­ã¿è¾¼ã¿å¤±æ•—: ", "invalid_xsd": "ç„¡åŠ¹ãªXSDãƒ•ã‚¡ã‚¤ãƒ«", "val_updated": "å€¤ãŒæ›´æ–°ã•ã‚Œã¾ã—ãŸ", "confirm_del": "å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ", "node_deleted": "å‰Šé™¤ã—ã¾ã—ãŸ", "validating": "æ¤œè¨¼ä¸­...", "valid_pass": "âœ… æ¤œè¨¼ã«åˆæ ¼ã—ã¾ã—ãŸï¼", "valid_pass_desc": "â€¢ å¿…é ˆè¦ç´ ã¯å…¨ã¦å­˜åœ¨ã—ã¾ã™<br>â€¢ æ§‹é€ ã¯æ­£ã—ã„ã§ã™<br>â€¢ å±æ€§ã¯æ­£ã—ã„ã§ã™", "valid_fail": "âŒ æ¤œè¨¼ã‚¨ãƒ©ãƒ¼", "valid_fail_desc": "<strong>å•é¡ŒãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸï¼š</strong>", "root_err": "ãƒ«ãƒ¼ãƒˆè¦ç´ ãŒå®šç¾©ã•ã‚Œã¦ã„ã¾ã›ã‚“", "missing_attr": "å¿…é ˆå±æ€§ãŒä¸è¶³ã—ã¦ã„ã¾ã™", "type_err": "å‹ã®ä¸ä¸€è‡´", "enum_err": "ç„¡åŠ¹ãªå€¤ã§ã™", "missing_child": "å¿…é ˆå­è¦ç´ ãŒä¸è¶³ã—ã¦ã„ã¾ã™", "max_occurs_err": "æœ€å¤§å‡ºç¾å›æ•°ã‚’è¶…ãˆã¦ã„ã¾ã™", "invalid_child": "ç„¡åŠ¹ãªå­è¦ç´ ã§ã™", "no_xml_export": "å‡ºåŠ›ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“", "xml_exported": "ä¿å­˜ã—ã¾ã—ãŸ", "confirm_clear": "å…¨ã¦æ¶ˆå»ã—ã¾ã™ã‹ï¼Ÿ", "cleared": "æ¶ˆå»ã—ã¾ã—ãŸ", "schema_elems": "è¦ç´ ä¸€è¦§:", "total_defs": "å®šç¾©æ•°", "no_child_defs": "å­è¦ç´ ã®å®šç¾©ãŒã‚ã‚Šã¾ã›ã‚“", "opt_complex": "è¤‡åˆå‹", "opt_select": "-- é¸æŠ --", "optional_attrs": "åˆ©ç”¨å¯èƒ½ãªå±æ€§", "err_invalid_name": "æœ‰åŠ¹ãªè¦ç´ åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„", "err_invalid_type": "XSDå‹ã¨ä¸€è‡´ã—ã¾ã›ã‚“", "theme_default": "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ", "theme_red": "ãƒ¢ãƒ©ãƒ³ãƒ‡ã‚£ãƒ»ãƒ¬ãƒƒãƒ‰", "theme_yellow": "ãƒ¢ãƒ©ãƒ³ãƒ‡ã‚£ãƒ»ã‚¤ã‚¨ãƒ­ãƒ¼", "theme_blue": "ãƒ¢ãƒ©ãƒ³ãƒ‡ã‚£ãƒ»ãƒ–ãƒ«ãƒ¼", "theme_green": "ãƒ¢ãƒ©ãƒ³ãƒ‡ã‚£ãƒ»ã‚°ãƒªãƒ¼ãƒ³", "theme_pink": "ãƒ¢ãƒ©ãƒ³ãƒ‡ã‚£ãƒ»ãƒ”ãƒ³ã‚¯" },
            "th": { "app_title": "ğŸ”§ XSD-based XML Editor", "app_subtitle": "à¹‚à¸«à¸¥à¸” XSD schema, à¹à¸à¹‰à¹„à¸‚à¹à¸¥à¸°à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¹€à¸­à¸à¸ªà¸²à¸£ XML à¸‚à¸­à¸‡à¸„à¸¸à¸“", "btn_load_xsd": "ğŸ“ à¹‚à¸«à¸¥à¸”à¹„à¸Ÿà¸¥à¹Œ XSD", "btn_validate": "âœ“ à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š XML", "btn_export": "ğŸ’¾ à¸ªà¹ˆà¸‡à¸­à¸­à¸ XML", "btn_clear": "ğŸ—‘ï¸ à¸¥à¹‰à¸²à¸‡à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”", "panel_xml_editor": "à¸•à¸±à¸§à¹à¸à¹‰à¹„à¸‚ XML", "view_tree": "à¸•à¸±à¸§à¹à¸à¹‰à¹„à¸‚à¹à¸šà¸šà¸•à¹‰à¸™à¹„à¸¡à¹‰ (Tree)", "view_source": "à¸£à¸«à¸±à¸ªà¸•à¹‰à¸™à¸‰à¸šà¸±à¸š XML", "msg_load_xsd_first": "à¸à¸£à¸¸à¸“à¸²à¹‚à¸«à¸¥à¸”à¹„à¸Ÿà¸¥à¹Œ XSD à¹€à¸à¸·à¹ˆà¸­à¹€à¸£à¸´à¹ˆà¸¡à¹à¸à¹‰à¹„à¸‚", "panel_xsd_info": "à¸‚à¹‰à¸­à¸¡à¸¹à¸¥ XSD Schema", "msg_no_schema": "à¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¹„à¸”à¹‰à¹‚à¸«à¸¥à¸” Schema", "status_ready": "à¸à¸£à¹‰à¸­à¸¡", "status_nodes": "à¹‚à¸«à¸™à¸”: 0", "modal_title_add": "à¹€à¸¥à¸·à¸­à¸ Element à¸—à¸µà¹ˆà¸ˆà¸°à¹€à¸à¸´à¹ˆà¸¡", "modal_title_edit": "à¹à¸à¹‰à¹„à¸‚ Element", "label_custom_elem": "Element à¸—à¸µà¹ˆà¹€à¸¥à¸·à¸­à¸", "label_node_value": "à¸„à¹ˆà¸²à¸‚à¸­à¸‡à¹‚à¸«à¸™à¸”", "label_attrs": "Attributes (à¹„à¸¡à¹ˆà¸šà¸±à¸‡à¸„à¸±à¸š)", "btn_add_attr": "+ à¹€à¸à¸´à¹ˆà¸¡ Attribute", "btn_cancel": "à¸¢à¸à¹€à¸¥à¸´à¸", "btn_confirm": "à¸¢à¸·à¸™à¸¢à¸±à¸™", "hint_enum": "âœ¨ à¹‚à¸«à¸¥à¸”à¸•à¸±à¸§à¹€à¸¥à¸·à¸­à¸à¸ˆà¸²à¸ XSD à¹à¸¥à¹‰à¸§", "hint_date": "ğŸ“… à¹€à¸¥à¸·à¸­à¸à¸§à¸±à¸™à¸—à¸µà¹ˆ", "hint_datetime": "ğŸ“… à¹€à¸¥à¸·à¸­à¸à¸§à¸±à¸™à¸—à¸µà¹ˆà¹à¸¥à¸°à¹€à¸§à¸¥à¸²", "hint_time": "â° à¹€à¸¥à¸·à¸­à¸à¹€à¸§à¸¥à¸²", "ph_attr_name": "à¸Šà¸·à¹ˆà¸­ Attribute", "ph_attr_val": "à¸„à¹ˆà¸²", "btn_delete": "à¸¥à¸š", "btn_add_child": "+ à¸¥à¸¹à¸ (Child)", "btn_modify": "à¹à¸à¹‰à¹„à¸‚", "xsd_loaded": "à¹‚à¸«à¸¥à¸” XSD Schema à¸ªà¸³à¹€à¸£à¹‡à¸ˆ", "load_fail": "à¹‚à¸«à¸¥à¸” XSD à¹„à¸¡à¹ˆà¸ªà¸³à¹€à¸£à¹‡à¸ˆ: ", "invalid_xsd": "à¹„à¸Ÿà¸¥à¹Œ XSD à¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡", "val_updated": "à¸­à¸±à¸›à¹€à¸”à¸•à¸„à¹ˆà¸²à¹à¸¥à¹‰à¸§", "confirm_del": "à¸•à¹‰à¸­à¸‡à¸à¸²à¸£à¸¥à¸šà¹‚à¸«à¸™à¸”à¸™à¸µà¹‰à¹ƒà¸Šà¹ˆà¹„à¸«à¸¡?", "node_deleted": "à¸¥à¸šà¹‚à¸«à¸™à¸”à¹à¸¥à¹‰à¸§", "validating": "à¸à¸³à¸¥à¸±à¸‡à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š...", "valid_pass": "âœ… XML à¸–à¸¹à¸à¸•à¹‰à¸­à¸‡à¸•à¸²à¸¡à¸¡à¸²à¸•à¸£à¸à¸²à¸™ XSD!", "valid_pass_desc": "â€¢ à¸à¸šà¸­à¸‡à¸„à¹Œà¸›à¸£à¸°à¸à¸­à¸šà¸—à¸µà¹ˆà¸ˆà¸³à¹€à¸›à¹‡à¸™à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”<br>â€¢ à¹‚à¸„à¸£à¸‡à¸ªà¸£à¹‰à¸²à¸‡à¸•à¸£à¸‡à¸•à¸²à¸¡ Schema<br>â€¢ Attributes à¸–à¸¹à¸à¸•à¹‰à¸­à¸‡", "valid_fail": "âŒ XML à¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡", "valid_fail_desc": "<strong>à¸à¸šà¸›à¸±à¸à¸«à¸²à¸”à¸±à¸‡à¸™à¸µà¹‰:</strong>", "root_err": "Root element à¹„à¸¡à¹ˆà¹„à¸”à¹‰à¸–à¸¹à¸à¸à¸³à¸«à¸™à¸”à¹ƒà¸™ Schema", "missing_attr": "à¸‚à¸²à¸” Attribute à¸—à¸µà¹ˆà¸ˆà¸³à¹€à¸›à¹‡à¸™", "type_err": "à¸„à¹ˆà¸²à¹„à¸¡à¹ˆà¸•à¸£à¸‡à¸•à¸²à¸¡à¸›à¸£à¸°à¹€à¸ à¸—à¸‚à¹‰à¸­à¸¡à¸¹à¸¥", "enum_err": "à¸„à¹ˆà¸²à¹„à¸¡à¹ˆà¸­à¸¢à¸¹à¹ˆà¹ƒà¸™à¸•à¸±à¸§à¹€à¸¥à¸·à¸­à¸à¸—à¸µà¹ˆà¸­à¸™à¸¸à¸à¸²à¸•", "missing_child": "à¸‚à¸²à¸” Element à¸¥à¸¹à¸à¸—à¸µà¹ˆà¸ˆà¸³à¹€à¸›à¹‡à¸™", "max_occurs_err": "à¸ˆà¸³à¸™à¸§à¸™à¸„à¸£à¸±à¹‰à¸‡à¸—à¸µà¹ˆà¸›à¸£à¸²à¸à¸à¹€à¸à¸´à¸™à¸à¸³à¸«à¸™à¸”", "invalid_child": "Element à¸¥à¸¹à¸à¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡", "no_xml_export": "à¹„à¸¡à¹ˆà¸¡à¸µ XML à¹ƒà¸«à¹‰à¸ªà¹ˆà¸‡à¸­à¸­à¸", "xml_exported": "à¸ªà¹ˆà¸‡à¸­à¸­à¸ XML à¹à¸¥à¹‰à¸§", "confirm_clear": "à¸•à¹‰à¸­à¸‡à¸à¸²à¸£à¸¥à¹‰à¸²à¸‡à¹€à¸™à¸·à¹‰à¸­à¸«à¸²à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”à¹ƒà¸Šà¹ˆà¹„à¸«à¸¡?", "cleared": "à¸¥à¹‰à¸²à¸‡à¹€à¸™à¸·à¹‰à¸­à¸«à¸²à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”à¹à¸¥à¹‰à¸§", "schema_elems": "Elements à¹ƒà¸™ Schema:", "total_defs": "à¸ˆà¸³à¸™à¸§à¸™à¸„à¸³à¸ˆà¸³à¸à¸±à¸”à¸„à¸§à¸²à¸¡à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”", "no_child_defs": "à¹„à¸¡à¹ˆà¸¡à¸µà¸à¸²à¸£à¸à¸³à¸«à¸™à¸” Element à¸¥à¸¹à¸à¹ƒà¸™ XSD", "opt_complex": "à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¹à¸šà¸šà¸‹à¸±à¸šà¸‹à¹‰à¸­à¸™ (Complex Type)", "opt_select": "-- à¸à¸£à¸¸à¸“à¸²à¹€à¸¥à¸·à¸­à¸ --", "optional_attrs": "Attribute à¸—à¸²à¸‡à¹€à¸¥à¸·à¸­à¸", "err_invalid_name": "à¸à¸£à¸¸à¸“à¸²à¸£à¸°à¸šà¸¸à¸Šà¸·à¹ˆà¸­ Element à¸—à¸µà¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡", "err_invalid_type": "à¸„à¹ˆà¸²à¹„à¸¡à¹ˆà¸•à¸£à¸‡à¸•à¸²à¸¡à¸›à¸£à¸°à¹€à¸ à¸— XSD", "theme_default": "à¸˜à¸µà¸¡à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™", "theme_red": "Morandi Red", "theme_yellow": "Morandi Yellow", "theme_blue": "Morandi Blue", "theme_green": "Morandi Green", "theme_pink": "Morandi Pink" },
            "ko": { "app_title": "ğŸ”§ XSD ê¸°ë°˜ XML í¸ì§‘ê¸°", "app_subtitle": "XSD ìŠ¤í‚¤ë§ˆë¥¼ ë¡œë“œí•˜ì—¬ XML ë¬¸ì„œë¥¼ í¸ì§‘í•˜ê³  ê²€ì¦í•˜ì„¸ìš”", "btn_load_xsd": "ğŸ“ XSD íŒŒì¼ ë¡œë“œ", "btn_validate": "âœ“ XML ê²€ì¦", "btn_export": "ğŸ’¾ XML ë‚´ë³´ë‚´ê¸°", "btn_clear": "ğŸ—‘ï¸ ëª¨ë‘ ì§€ìš°ê¸°", "panel_xml_editor": "XML í¸ì§‘ê¸°", "view_tree": "íŠ¸ë¦¬ í¸ì§‘ê¸°", "view_source": "XML ì†ŒìŠ¤", "msg_load_xsd_first": "í¸ì§‘ì„ ì‹œì‘í•˜ë ¤ë©´ XSD íŒŒì¼ì„ ë¡œë“œí•˜ì„¸ìš”", "panel_xsd_info": "XSD ìŠ¤í‚¤ë§ˆ ì •ë³´", "msg_no_schema": "ë¡œë“œëœ ìŠ¤í‚¤ë§ˆ ì—†ìŒ", "status_ready": "ì¤€ë¹„ë¨", "status_nodes": "ë…¸ë“œ ìˆ˜: 0", "modal_title_add": "ì¶”ê°€í•  ìš”ì†Œ ì„ íƒ", "modal_title_edit": "ìš”ì†Œ í¸ì§‘", "label_custom_elem": "ì„ íƒëœ ìš”ì†Œ", "label_node_value": "ë…¸ë“œ ê°’", "label_attrs": "ì†ì„± (ì„ íƒ ì‚¬í•­)", "btn_add_attr": "+ ì†ì„± ì¶”ê°€", "btn_cancel": "ì·¨ì†Œ", "btn_confirm": "í™•ì¸", "hint_enum": "âœ¨ XSDì—ì„œ ì˜µì…˜ ë¡œë“œë¨", "hint_date": "ğŸ“… ë‚ ì§œ ì„ íƒ", "hint_datetime": "ğŸ“… ë‚ ì§œ ë° ì‹œê°„ ì„ íƒ", "hint_time": "â° ì‹œê°„ ì„ íƒ", "ph_attr_name": "ì†ì„± ì´ë¦„", "ph_attr_val": "ê°’", "btn_delete": "ì‚­ì œ", "btn_add_child": "+ ìì‹ ë…¸ë“œ", "btn_modify": "ìˆ˜ì •", "xsd_loaded": "XSD ìŠ¤í‚¤ë§ˆ ë¡œë“œë¨", "load_fail": "XSD ë¡œë“œ ì‹¤íŒ¨: ", "invalid_xsd": "ìœ íš¨í•˜ì§€ ì•Šì€ XSD íŒŒì¼", "val_updated": "ê°’ ì—…ë°ì´íŠ¸ë¨", "confirm_del": "ì´ ë…¸ë“œë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?", "node_deleted": "ë…¸ë“œ ì‚­ì œë¨", "validating": "ê²€ì¦ ì¤‘...", "valid_pass": "âœ… XMLì´ XSD ê·œì¹™ì„ ì¤€ìˆ˜í•©ë‹ˆë‹¤!", "valid_pass_desc": "â€¢ ëª¨ë“  í•„ìˆ˜ ìš”ì†Œ ì¡´ì¬<br>â€¢ êµ¬ì¡°ê°€ ìŠ¤í‚¤ë§ˆì™€ ì¼ì¹˜í•¨<br>â€¢ ì†ì„±ì´ ì˜¬ë°”ë¦„", "valid_fail": "âŒ XMLì´ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤", "valid_fail_desc": "<strong>ë°œê²¬ëœ ë¬¸ì œ:</strong>", "root_err": "ë£¨íŠ¸ ìš”ì†Œê°€ ìŠ¤í‚¤ë§ˆì— ì •ì˜ë˜ì§€ ì•ŠìŒ", "missing_attr": "í•„ìˆ˜ ì†ì„± ëˆ„ë½", "type_err": "ê°’ì˜ í˜•ì‹ì´ ì¼ì¹˜í•˜ì§€ ì•ŠìŒ", "enum_err": "í—ˆìš©ëœ ì˜µì…˜ì— ì—†ëŠ” ê°’", "missing_child": "í•„ìˆ˜ ìì‹ ìš”ì†Œ ëˆ„ë½", "max_occurs_err": "ìµœëŒ€ ë°œìƒ íšŸìˆ˜ ì´ˆê³¼", "invalid_child": "ìœ íš¨í•˜ì§€ ì•Šì€ ìì‹ ìš”ì†Œ", "no_xml_export": "ë‚´ë³´ë‚¼ XMLì´ ì—†ìŒ", "xml_exported": "XML ë‚´ë³´ë‚´ê¸° ì™„ë£Œ", "confirm_clear": "ëª¨ë“  ë‚´ìš©ì„ ì§€ìš°ì‹œê² ìŠµë‹ˆê¹Œ?", "cleared": "ëª¨ë“  ë‚´ìš© ì§€ì›Œì§", "schema_elems": "ìŠ¤í‚¤ë§ˆ ìš”ì†Œ:", "total_defs": "ì´ ì •ì˜ ìˆ˜", "no_child_defs": "XSDì— ì •ì˜ëœ ìì‹ ìš”ì†Œê°€ ì—†ìŒ", "opt_complex": "ë³µí•© ìœ í˜• (Complex Type)", "opt_select": "-- ì„ íƒ --", "optional_attrs": "ì„ íƒ ì†ì„±", "err_invalid_name": "ìœ íš¨í•œ ìš”ì†Œ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”", "err_invalid_type": "ê°’ì´ XSD í˜•ì‹ê³¼ ì¼ì¹˜í•˜ì§€ ì•ŠìŒ", "theme_default": "ê¸°ë³¸ í…Œë§ˆ", "theme_red": "ëª¨ë€ë”” ë ˆë“œ", "theme_yellow": "ëª¨ë€ë”” ì˜ë¡œìš°", "theme_blue": "ëª¨ë€ë”” ë¸”ë£¨", "theme_green": "ëª¨ë€ë”” ê·¸ë¦°", "theme_pink": "ëª¨ë€ë”” í•‘í¬" },
            "fr": { "app_title": "ğŸ”§ Ã‰diteur XML basÃ© sur XSD", "app_subtitle": "Chargez un schÃ©ma XSD, Ã©ditez et validez vos documents XML", "btn_load_xsd": "ğŸ“ Charger XSD", "btn_validate": "âœ“ Valider XML", "btn_export": "ğŸ’¾ Exporter XML", "btn_clear": "ğŸ—‘ï¸ Tout effacer", "panel_xml_editor": "Ã‰diteur XML", "view_tree": "Vue Arborescence", "view_source": "Source XML", "msg_load_xsd_first": "Veuillez charger un fichier XSD pour commencer", "panel_xsd_info": "Infos SchÃ©ma XSD", "msg_no_schema": "Aucun schÃ©ma chargÃ©", "status_ready": "PrÃªt", "status_nodes": "NÅ“uds: 0", "modal_title_add": "Ajouter un Ã©lÃ©ment", "modal_title_edit": "Ã‰diter l'Ã©lÃ©ment", "label_custom_elem": "Ã‰lÃ©ment sÃ©lectionnÃ©", "label_node_value": "Valeur du nÅ“ud", "label_attrs": "Attributs (Optionnel)", "btn_add_attr": "+ Ajouter Attribut", "btn_cancel": "Annuler", "btn_confirm": "Confirmer", "hint_enum": "âœ¨ Options chargÃ©es depuis XSD", "hint_date": "ğŸ“… SÃ©lectionner la date", "hint_datetime": "ğŸ“… Date et heure", "hint_time": "â° SÃ©lectionner l'heure", "ph_attr_name": "Nom Attribut", "ph_attr_val": "Valeur", "btn_delete": "Supprimer", "btn_add_child": "+ Enfant", "btn_modify": "Ã‰diter", "xsd_loaded": "SchÃ©ma XSD chargÃ©", "load_fail": "Ã‰chec du chargement: ", "invalid_xsd": "Fichier XSD invalide", "val_updated": "Valeur mise Ã  jour", "confirm_del": "Supprimer ce nÅ“ud ?", "node_deleted": "NÅ“ud supprimÃ©", "validating": "Validation...", "valid_pass": "âœ… XML valide selon XSD !", "valid_pass_desc": "â€¢ Tous les Ã©lÃ©ments requis sont prÃ©sents<br>â€¢ La structure correspond au schÃ©ma<br>â€¢ Les attributs sont corrects", "valid_fail": "âŒ XML invalide", "valid_fail_desc": "<strong>ProblÃ¨mes trouvÃ©s :</strong>", "root_err": "Ã‰lÃ©ment racine non dÃ©fini dans le schÃ©ma", "missing_attr": "Attribut requis manquant", "type_err": "Type de valeur incorrect", "enum_err": "Valeur non autorisÃ©e", "missing_child": "Enfant requis manquant", "max_occurs_err": "Max occurrences dÃ©passÃ©", "invalid_child": "Enfant invalide", "no_xml_export": "Aucun XML Ã  exporter", "xml_exported": "XML exportÃ©", "confirm_clear": "Tout effacer ?", "cleared": "Contenu effacÃ©", "schema_elems": "Ã‰lÃ©ments du schÃ©ma :", "total_defs": "Total dÃ©finitions", "no_child_defs": "Aucun enfant dÃ©fini dans XSD", "opt_complex": "Type Complexe", "opt_select": "-- SÃ©lectionner --", "optional_attrs": "Attributs Optionnels", "err_invalid_name": "Veuillez entrer un nom valide", "err_invalid_type": "La valeur ne correspond pas au type", "theme_default": "DÃ©faut", "theme_red": "Rouge Morandi", "theme_yellow": "Jaune Morandi", "theme_blue": "Bleu Morandi", "theme_green": "Vert Morandi", "theme_pink": "Rose Morandi" },
            "de": { "app_title": "ğŸ”§ XSD-basierter XML-Editor", "app_subtitle": "Laden Sie ein XSD-Schema, bearbeiten und validieren Sie XML", "btn_load_xsd": "ğŸ“ XSD laden", "btn_validate": "âœ“ XML validieren", "btn_export": "ğŸ’¾ XML exportieren", "btn_clear": "ğŸ—‘ï¸ Alles lÃ¶schen", "panel_xml_editor": "XML-Editor", "view_tree": "Baumansicht", "view_source": "XML-Quelle", "msg_load_xsd_first": "Bitte laden Sie eine XSD-Datei", "panel_xsd_info": "XSD-Schema-Info", "msg_no_schema": "Kein Schema geladen", "status_ready": "Bereit", "status_nodes": "Knoten: 0", "modal_title_add": "Element hinzufÃ¼gen", "modal_title_edit": "Element bearbeiten", "label_custom_elem": "AusgewÃ¤hltes Element", "label_node_value": "Knotenwert", "label_attrs": "Attribute (Optional)", "btn_add_attr": "+ Attribut hinzufÃ¼gen", "btn_cancel": "Abbrechen", "btn_confirm": "BestÃ¤tigen", "hint_enum": "âœ¨ Optionen aus XSD geladen", "hint_date": "ğŸ“… Datum wÃ¤hlen", "hint_datetime": "ğŸ“… Datum & Zeit wÃ¤hlen", "hint_time": "â° Zeit wÃ¤hlen", "ph_attr_name": "Attr. Name", "ph_attr_val": "Wert", "btn_delete": "LÃ¶schen", "btn_add_child": "+ Kind", "btn_modify": "Bearbeiten", "xsd_loaded": "XSD-Schema geladen", "load_fail": "Laden fehlgeschlagen: ", "invalid_xsd": "UngÃ¼ltige XSD-Datei", "val_updated": "Wert aktualisiert", "confirm_del": "Diesen Knoten lÃ¶schen?", "node_deleted": "Knoten gelÃ¶scht", "validating": "Validierung...", "valid_pass": "âœ… XML ist gÃ¼ltig!", "valid_pass_desc": "â€¢ Alle erforderlichen Elemente vorhanden<br>â€¢ Struktur entspricht Schema<br>â€¢ Attribute sind korrekt", "valid_fail": "âŒ XML ist ungÃ¼ltig", "valid_fail_desc": "<strong>Gefundene Probleme:</strong>", "root_err": "Wurzelelement nicht im Schema definiert", "missing_attr": "Fehlendes Attribut", "type_err": "Werttyp falsch", "enum_err": "Wert nicht erlaubt", "missing_child": "Fehlendes Kind-Element", "max_occurs_err": "Max. Vorkommen Ã¼berschritten", "invalid_child": "UngÃ¼ltiges Kind-Element", "no_xml_export": "Kein XML zum Exportieren", "xml_exported": "XML exportiert", "confirm_clear": "Alles lÃ¶schen?", "cleared": "Inhalt gelÃ¶scht", "schema_elems": "Schema-Elemente:", "total_defs": "Definitionen gesamt", "no_child_defs": "Keine Kind-Elemente in XSD definiert", "opt_complex": "Komplexer Typ", "opt_select": "-- WÃ¤hlen --", "optional_attrs": "Optionale Attribute", "err_invalid_name": "Bitte gÃ¼ltigen Namen eingeben", "err_invalid_type": "Wert entspricht nicht dem Typ", "theme_default": "Standard", "theme_red": "Morandi Rot", "theme_yellow": "Morandi Gelb", "theme_blue": "Morandi Blau", "theme_green": "Morandi GrÃ¼n", "theme_pink": "Morandi Pink" }
        };

        let currentLang = 'en';

        // Auto-detect browser language / è‡ªå‹•åµæ¸¬ç€è¦½å™¨èªç³»
        function initLanguage() {
            const browserLang = navigator.language || navigator.userLanguage;
            if (browserLang.startsWith('zh-TW') || browserLang.startsWith('zh-HK')) currentLang = 'zh-TW';
            else if (browserLang.startsWith('zh')) currentLang = 'zh-CN';
            else if (browserLang.startsWith('ja')) currentLang = 'ja';
            else if (browserLang.startsWith('th')) currentLang = 'th';
            else if (browserLang.startsWith('ko')) currentLang = 'ko';
            else if (browserLang.startsWith('fr')) currentLang = 'fr';
            else if (browserLang.startsWith('de')) currentLang = 'de';
            else currentLang = 'en';
            
            document.getElementById('langSelect').value = currentLang;
            updateInterface();
        }

        // Update interface texts based on selected language / æ ¹æ“šé¸æ“‡çš„èªè¨€æ›´æ–°ä»‹é¢æ–‡å­—
        function changeLanguage(lang) {
            currentLang = lang;
            updateInterface();
            if (xmlDoc) renderXMLTree();
            if (xsdElements.size > 0) updateSchemaInfo();
        }

        // Helper to get translation / å–å¾—ç¿»è­¯çš„è¼”åŠ©å‡½å¼
        function t(key) { return translations[currentLang][key] || key; }

        function updateInterface() {
            document.querySelectorAll('[data-i18n]').forEach(elem => {
                elem.innerHTML = t(elem.getAttribute('data-i18n'));
            });
            document.querySelectorAll('.attr-name').forEach(el => el.placeholder = t('ph_attr_name'));
            document.querySelectorAll('.attr-value').forEach(el => el.placeholder = t('ph_attr_val'));
            document.getElementById('elementValueInput').placeholder = t('label_node_value');
            const modalBtn = document.querySelector('.modal-btn.primary');
            if(modalBtn) modalBtn.textContent = t('btn_confirm');
        }

        // Initialize on load / è¼‰å…¥æ™‚åˆå§‹åŒ–
        window.addEventListener('DOMContentLoaded', initLanguage);

        // DOM Elements for Source Editor / åŸå§‹ç¢¼ç·¨è¼¯å™¨çš„ DOM å…ƒç´ 
        const xmlRawInput = document.getElementById('xmlRawInput');
        const xmlHighlight = document.getElementById('xmlHighlight').querySelector('code');
        const lineNumbers = document.getElementById('lineNumbers');
        const xmlEditorContainer = document.getElementById('xmlEditorContainer');

        // Sync syntax highlighting on input / è¼¸å…¥æ™‚åŒæ­¥èªæ³•é«˜äº®
        xmlRawInput.addEventListener('input', updateSyntaxHighlighting);
        // Sync scrolling / åŒæ­¥æ²å‹•
        xmlRawInput.addEventListener('scroll', () => {
             xmlEditorContainer.scrollTop = xmlRawInput.scrollTop;
             xmlEditorContainer.scrollLeft = xmlRawInput.scrollLeft;
        });

        // --- File Loading Logic / æª”æ¡ˆè®€å–é‚è¼¯ ---
        document.getElementById('xsdFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const parser = new DOMParser();
                        xsdDoc = parser.parseFromString(e.target.result, 'text/xml');
                        if (xsdDoc.getElementsByTagName('parsererror').length > 0) throw new Error(t('invalid_xsd'));
                        
                        parseXSDSchema();
                        initializeXMLDocument();
                        document.getElementById('validateBtn').disabled = false;
                        updateStatus(t('xsd_loaded'));
                    } catch (error) {
                        alert(t('load_fail') + error.message);
                    }
                };
                reader.readAsText(file);
            }
        });

        // --- XSD Parsing Logic (Core) / XSD è§£æé‚è¼¯ (æ ¸å¿ƒ) ---
        function parseXSDSchema() {
            xsdElements.clear();
            const elements = xsdDoc.getElementsByTagNameNS('http://www.w3.org/2001/XMLSchema', 'element');
            const complexTypes = xsdDoc.getElementsByTagNameNS('http://www.w3.org/2001/XMLSchema', 'complexType');
            const simpleTypes = xsdDoc.getElementsByTagNameNS('http://www.w3.org/2001/XMLSchema', 'simpleType');
            const attributes = xsdDoc.getElementsByTagNameNS('http://www.w3.org/2001/XMLSchema', 'attribute');

            // Calculate XPath for an element node / è¨ˆç®—å…ƒç´ ç¯€é»çš„ XPath
            // Traverses up until the schema root / å¾€ä¸Šéæ­·ç›´åˆ° schema æ ¹ç¯€é»
            function getElementXPath(elem) {
                let path = [];
                let current = elem;
                while (current) {
                    if (current.localName === 'element') {
                        let name = current.getAttribute('name');
                        if (!name) name = current.getAttribute('ref'); // Handle ref / è™•ç†å¼•ç”¨
                        
                        if (name) {
                            if (name.includes(':')) name = name.split(':')[1]; // Strip prefix / å»é™¤å‰ç¶´
                            path.unshift(name);
                        }
                    }
                    if (current.localName === 'schema') break;
                    current = current.parentNode;
                }
                return path.length > 0 ? '/' + path.join('/') : '';
            }

            // Extract constraints from simpleType restrictions / å¾ simpleType é™åˆ¶ä¸­æå–ç´„æŸæ¢ä»¶
            function extractConstraints(typeNode) {
                const constraints = {};
                if (!typeNode) return constraints;
                const restriction = typeNode.querySelector('restriction');
                if (restriction) {
                    const checkAttrs = ['pattern', 'totalDigits', 'fractionDigits', 'minLength', 'maxLength', 'minInclusive', 'maxInclusive', 'minExclusive', 'maxExclusive'];
                    checkAttrs.forEach(attr => {
                        const node = restriction.querySelector(attr);
                        if (node) constraints[attr] = node.getAttribute('value');
                    });
                }
                return constraints;
            }

            // Extract enumeration values / æå–åˆ—èˆ‰å€¼
            function getEnumerations(typeNode) {
                if (!typeNode) return [];
                const restriction = typeNode.querySelector('restriction');
                if (!restriction) return [];
                const enumNodes = restriction.querySelectorAll('enumeration');
                return Array.from(enumNodes).map(node => node.getAttribute('value'));
            }

            // Parse Complex Type Definitions / è§£æè¤‡é›œé¡å‹å®šç¾©
            function parseComplexType(typeElement) {
                const children = [];
                const attrs = [];
                let hasChildren = false;
                let valueType = null;
                let enumerations = [];
                let constraints = {};

                const simpleContent = typeElement.querySelector('simpleContent');
                if (simpleContent) {
                    // Complex Type with Simple Content (e.g., value + attributes)
                    const extension = simpleContent.querySelector('extension');
                    if (extension) {
                        valueType = extension.getAttribute('base');
                        Array.from(extension.querySelectorAll('attribute')).forEach(attr => {
                            const name = attr.getAttribute('name') || attr.getAttribute('ref');
                            if (name) attrs.push({ name: name, use: attr.getAttribute('use') || 'optional' });
                        });
                    }
                    const restriction = simpleContent.querySelector('restriction');
                    if (restriction) {
                        enumerations = getEnumerations(simpleContent);
                        constraints = extractConstraints(simpleContent);
                    }
                } else {
                    // Standard Complex Type (Sequence/Choice/All)
                    const sequence = typeElement.querySelector('sequence');
                    const choice = typeElement.querySelector('choice');
                    const all = typeElement.querySelector('all');
                    const elements = (sequence || choice || all);
                    
                    if (elements) {
                        hasChildren = true;
                        Array.from(elements.children).forEach(elem => {
                            if (elem.nodeName.endsWith('element')) {
                                const name = elem.getAttribute('name') || elem.getAttribute('ref');
                                if (name) {
                                    children.push({
                                        name: name,
                                        minOccurs: elem.getAttribute('minOccurs') || '1',
                                        maxOccurs: elem.getAttribute('maxOccurs') || '1'
                                    });
                                }
                            }
                        });
                    }
                    Array.from(typeElement.querySelectorAll('attribute')).forEach(attr => {
                        const name = attr.getAttribute('name') || attr.getAttribute('ref');
                        if (name) attrs.push({ name: name, use: attr.getAttribute('use') || 'optional' });
                    });
                }
                
                return { hasChildren, valueType, childElements: children, attributes: attrs, enumerations: enumerations, constraints: constraints };
            }

            // Parse Element Definition / è§£æå…ƒç´ å®šç¾©
            function parseElement(elem) {
                const name = elem.getAttribute('name');
                const typeAttr = elem.getAttribute('type');
                let definition = {
                    element: elem,
                    minOccurs: elem.getAttribute('minOccurs'),
                    maxOccurs: elem.getAttribute('maxOccurs'),
                    hasChildren: false,
                    valueType: null,
                    childElements: [],
                    attributes: [],
                    enumerations: [],
                    constraints: {},
                    documentation: "",
                    xsdType: null, 
                    xsdTypeName: null,
                    xpath: getElementXPath(elem) // Calculate XPath / è¨ˆç®— XPath
                };
                
                // Extract Documentation / æå–èªªæ˜æ–‡ä»¶
                const annotation = elem.querySelector('annotation');
                if (annotation) {
                    const docs = annotation.querySelectorAll('documentation');
                    for(let doc of docs) {
                        if(doc.getAttribute('source') === 'Definition') {
                            definition.documentation = doc.textContent.trim();
                            break;
                        }
                    }
                }
                
                // Handle Named Types (type="...") / è™•ç†å…·åé¡å‹
                if (typeAttr) {
                    definition.xsdTypeName = typeAttr;
                    const typeDef = xsdDoc.getElementById(typeAttr) || 
                                    Array.from(complexTypes).find(t => t.getAttribute('name') === typeAttr) || 
                                    Array.from(simpleTypes).find(s => s.getAttribute('name') === typeAttr);
                    
                    if (typeDef) {
                        if (typeDef.nodeName.endsWith('complexType')) {
                            definition.xsdType = 'ComplexType';
                            const parsedType = parseComplexType(typeDef);
                            Object.assign(definition, parsedType);
                        } else if (typeDef.nodeName.endsWith('simpleType')) {
                            definition.xsdType = 'SimpleType';
                            const restriction = typeDef.querySelector('restriction');
                            if (restriction) {
                                definition.valueType = restriction.getAttribute('base');
                                definition.enumerations = getEnumerations(typeDef);
                                definition.constraints = extractConstraints(typeDef);
                            }
                        }
                    } else {
                        if(typeAttr.startsWith('xs:')) definition.xsdType = 'SimpleType';
                        definition.valueType = typeAttr; 
                    }
                }
                
                // Handle Inline Types / è™•ç†è¡Œå…§å®šç¾©é¡å‹
                const inlineComplexType = elem.querySelector('complexType');
                const inlineSimpleType = elem.querySelector('simpleType');

                if (inlineComplexType) {
                    definition.xsdType = 'ComplexType';
                    definition.xsdTypeName = '(Anonymous)';
                    const parsedType = parseComplexType(inlineComplexType);
                    Object.assign(definition, parsedType);
                } else if (inlineSimpleType) {
                     definition.xsdType = 'SimpleType';
                     definition.xsdTypeName = '(Anonymous)';
                     const restriction = inlineSimpleType.querySelector('restriction');
                     if (restriction) {
                         definition.valueType = restriction.getAttribute('base');
                         definition.enumerations = getEnumerations(inlineSimpleType);
                         definition.constraints = extractConstraints(inlineSimpleType);
                     }
                }
                
                // Fallback for simple elements without explicit type / ç„¡æ˜ç¢ºé¡å‹çš„ç°¡å–®å…ƒç´ è™•ç†
                if (!typeAttr && !inlineComplexType && !inlineSimpleType) {
                    const isSimple = !elem.querySelector('element') && !elem.querySelector('sequence') && !elem.querySelector('choice') && !elem.querySelector('all');
                    if (isSimple) {
                        definition.valueType = 'xs:string';
                        definition.xsdType = 'SimpleType';
                        definition.xsdTypeName = 'xs:string';
                    }
                }

                return definition;
            }

            // Main Loop: Parse all top-level elements / ä¸»è¿´åœˆï¼šè§£ææ‰€æœ‰é ‚å±¤å…ƒç´ 
            for (let elem of elements) {
                const name = elem.getAttribute('name');
                if (name) xsdElements.set(name, parseElement(elem));
            }
            
            updateSchemaInfo();
        }

        // Update the Right Panel Info / æ›´æ–°å³å´è³‡è¨Šé¢æ¿
        function updateSchemaInfo() {
            const schemaInfo = document.getElementById('schemaInfo');
            schemaInfo.innerHTML = `
                <h3 style="color: #4b5563; margin-bottom: 10px;">${t('schema_elems')}</h3>
                <ul style="list-style: none; padding: 0;">
                    ${Array.from(xsdElements.entries()).map(([name, def]) => {
                        let constraintsHtml = '<div class="constraints-container">';
                        
                        // Type Badges
                        if (def.xsdType) {
                            const colorClass = def.xsdType === 'ComplexType' ? 'badge-complex' : 'badge-simple';
                            const displayTypeName = def.xsdTypeName && def.xsdTypeName !== '(Anonymous)' ? `: ${def.xsdTypeName}` : '';
                            constraintsHtml += `<span class="constraint-badge ${colorClass}">${def.xsdType}${displayTypeName}</span>`;
                        }

                        // Occurs Badges
                        if(def.minOccurs) constraintsHtml += `<span class="constraint-badge badge-count">min: ${def.minOccurs}</span>`;
                        if(def.maxOccurs) constraintsHtml += `<span class="constraint-badge badge-count">max: ${def.maxOccurs}</span>`;
                        
                        // Detailed Constraints Badges
                        if(def.constraints) {
                            if(def.constraints.pattern) constraintsHtml += `<span class="constraint-badge badge-pattern">Pattern: ${def.constraints.pattern}</span>`;
                            if(def.constraints.totalDigits) constraintsHtml += `<span class="constraint-badge badge-number">TotalDigits: ${def.constraints.totalDigits}</span>`;
                            if(def.constraints.fractionDigits) constraintsHtml += `<span class="constraint-badge badge-number">FracDigits: ${def.constraints.fractionDigits}</span>`;
                            if(def.constraints.minLength) constraintsHtml += `<span class="constraint-badge badge-length">MinLen: ${def.constraints.minLength}</span>`;
                            if(def.constraints.maxLength) constraintsHtml += `<span class="constraint-badge badge-length">MaxLen: ${def.constraints.maxLength}</span>`;
                            if(def.constraints.minInclusive) constraintsHtml += `<span class="constraint-badge badge-number">Min: ${def.constraints.minInclusive}</span>`;
                            if(def.constraints.maxInclusive) constraintsHtml += `<span class="constraint-badge badge-number">Max: ${def.constraints.maxInclusive}</span>`;
                        }
                        
                        // XPath Badge
                        if(def.xpath) {
                            constraintsHtml += `<span class="constraint-badge badge-xpath" title="XPath">${def.xpath}</span>`;
                        }
                        
                        constraintsHtml += '</div>';

                        return `<li style="padding: 8px; background: rgba(102, 126, 234, 0.05); margin: 8px 0; border-radius: 5px;">
                            <div style="font-weight:600;">ğŸ“„ ${name}</div>
                            ${def.documentation ? `<div style="color: #666; font-size: 0.9em; margin-left: 24px; margin-top: 4px;">${def.documentation}</div>` : ''}
                            ${constraintsHtml}
                        </li>`;
                    }).join('')}
                </ul>
                <p style="margin-top: 15px; color: #6b7280;">${t('total_defs')} ${xsdElements.size}</p>
            `;
        }

        // Initialize minimal XML from XSD / å¾ XSD åˆå§‹åŒ–æœ€å° XML
        function initializeXMLDocument() {
            const rootElements = xsdDoc.getElementsByTagNameNS('http://www.w3.org/2001/XMLSchema', 'element');
            if (rootElements.length > 0) {
                const rootName = rootElements[0].getAttribute('name');
                const xmlString = `<?xml version="1.0" encoding="UTF-8"?>\n<${rootName}></${rootName}>`;
                xmlDoc = new DOMParser().parseFromString(xmlString, 'text/xml');
                
                // Handle Namespace / è™•ç†å‘½åç©ºé–“
                const targetNamespace = xsdDoc.documentElement.getAttribute('targetNamespace');
                if (targetNamespace) xmlDoc.documentElement.setAttribute('xmlns', targetNamespace);
                
                const schemaLocation = xsdDoc.documentElement.getAttribute('schemaLocation');
                if (schemaLocation) {
                    xmlDoc.documentElement.setAttribute('xsi:schemaLocation', schemaLocation);
                    xmlDoc.documentElement.setAttribute('xmlns:xsi', 'http://www.w3.org/2001/XMLSchema-instance');
                }
                renderXMLTree();
            }
        }

        // Render Tree View (Recursive) / æ¸²æŸ“æ¨¹ç‹€è¦–åœ– (éè¿´)
        function renderXMLTree() {
            const treeView = document.getElementById('treeView');
            treeView.innerHTML = '';
            if (xmlDoc && xmlDoc.documentElement) {
                treeView.appendChild(createTreeNode(xmlDoc.documentElement, true));
                updateNodeCount();
            }
        }
        
        // Serialize DOM to String / å°‡ DOM åºåˆ—åŒ–ç‚ºå­—ä¸²
        function getXmlString() {
            if (!xmlDoc) return '';
            const serializer = new XMLSerializer();
            let formatted = '', indent = '', tab = '  ';
            serializer.serializeToString(xmlDoc).split(/>\s*</).forEach(node => {
                if (node.match( /^\/\w/ )) indent = indent.substring(tab.length);
                formatted += indent + '<' + node + '>\r\n';
                if (node.match( /^<?\w[^>]*[^\/]$/ )) indent += tab;
            });
            return formatted.substring(1, formatted.length-3);
        }

        // Update Source View / æ›´æ–°åŸå§‹ç¢¼è¦–åœ–
        function updateXmlView() {
            if (xmlDoc) { xmlRawInput.value = getXmlString(); updateSyntaxHighlighting(); }
        }

        // Syntax Highlighting Logic / èªæ³•é«˜äº®é‚è¼¯
        function updateSyntaxHighlighting() {
            const code = xmlRawInput.value;
            const highlightedCode = code.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;')
                .replace(/(&lt;\/?[\w:-]+)/g, '<span class="xml-tag">$1</span>')
                .replace(/([\w:-]+)=(&quot;.*?&quot;)/g, '<span class="xml-attr-name">$1</span>=<span class="xml-attr-value">$2</span>')
                .replace(/(&gt;)([^&lt;]+)(&lt;)/g, '$1<span class="xml-content">$2</span>$3');
            xmlHighlight.innerHTML = highlightedCode;
            lineNumbers.innerHTML = Array.from({length: code.split('\n').length}, (_, i) => i + 1).join('<br>');
        }

        function switchToXmlView() {
            document.getElementById('treeView').style.display = 'none';
            document.getElementById('xmlEditorContainer').style.display = 'block';
            document.getElementById('showTreeViewBtn').classList.remove('active');
            document.getElementById('showXmlViewBtn').classList.add('active');
            updateXmlView();
        }

        function switchToTreeView() {
            const parser = new DOMParser();
            const newXmlDoc = parser.parseFromString(xmlRawInput.value, 'text/xml');
            if (newXmlDoc.getElementsByTagName('parsererror').length > 0) {
                alert(t('msg_load_xsd_first')); return;
            }
            xmlDoc = newXmlDoc;
            renderXMLTree();
            document.getElementById('treeView').style.display = 'block';
            document.getElementById('xmlEditorContainer').style.display = 'none';
            document.getElementById('showTreeViewBtn').classList.add('active');
            document.getElementById('showXmlViewBtn').classList.remove('active');
        }

        // Create DOM for a single tree node / å»ºç«‹å–®ä¸€æ¨¹ç‹€ç¯€é»çš„ DOM
        function createTreeNode(xmlNode, isRoot = false) {
            const nodeDiv = document.createElement('div');
            nodeDiv.className = isRoot ? 'tree-node root' : 'tree-node';
            nodeDiv.dataset.nodeId = nodeIdCounter++;
            
            const header = document.createElement('div');
            header.className = 'node-header';
            const hasChildren = xmlNode.children.length > 0;
            
            if (hasChildren) {
                const toggleBtn = document.createElement('span');
                toggleBtn.className = 'toggle-btn';
                toggleBtn.textContent = 'âˆ’';
                toggleBtn.onclick = function(e) { e.stopPropagation(); toggleNode(this); };
                header.appendChild(toggleBtn);
            } else {
                const spacer = document.createElement('span');
                spacer.style.width = '28px'; spacer.style.display = 'inline-block';
                header.appendChild(spacer);
            }
            
            const tagSpan = document.createElement('span');
            tagSpan.className = 'node-tag';
            tagSpan.textContent = '<' + xmlNode.nodeName;
            header.appendChild(tagSpan);
            
            for (let attr of xmlNode.attributes || []) {
                const attrSpan = document.createElement('span');
                attrSpan.className = 'node-attribute';
                attrSpan.textContent = ` ${attr.name}="${attr.value}"`;
                header.appendChild(attrSpan);
            }
            
            const closeTagSpan = document.createElement('span');
            closeTagSpan.className = 'node-tag'; closeTagSpan.textContent = '>';
            header.appendChild(closeTagSpan);
            
            if (!hasChildren && xmlNode.textContent) {
                const valueSpan = document.createElement('span');
                valueSpan.className = 'node-value';
                valueSpan.textContent = xmlNode.textContent;
                header.appendChild(valueSpan);
            }
            
            const addBtn = document.createElement('button');
            addBtn.className = 'add-btn'; addBtn.textContent = t('btn_add_child');
            addBtn.onclick = function(e) { e.stopPropagation(); addChildNode(xmlNode); };
            header.appendChild(addBtn);

            if (!isRoot) {
                const editBtn = document.createElement('button');
                editBtn.className = 'add-btn edit-btn'; editBtn.textContent = t('btn_modify');
                editBtn.onclick = function(e) { e.stopPropagation(); editNode(xmlNode); };
                header.appendChild(editBtn);

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-btn'; deleteBtn.textContent = t('btn_delete');
                deleteBtn.onclick = function(e) { e.stopPropagation(); deleteNode(xmlNode, nodeDiv); };
                header.appendChild(deleteBtn);
            }
            
            nodeDiv.appendChild(header);
            
            if (hasChildren) {
                const childrenDiv = document.createElement('div');
                childrenDiv.className = 'node-children';
                for (let child of xmlNode.children) {
                    childrenDiv.appendChild(createTreeNode(child));
                }
                nodeDiv.appendChild(childrenDiv);
            }
            return nodeDiv;
        }

        function toggleNode(btn) {
            btn.classList.toggle('collapsed');
            btn.textContent = btn.classList.contains('collapsed') ? '+' : 'âˆ’';
            const childrenDiv = btn.closest('.tree-node').querySelector('.node-children');
            if (childrenDiv) childrenDiv.classList.toggle('collapsed');
        }

        // Logic to add a child node / æ–°å¢å­ç¯€é»é‚è¼¯
        function addChildNode(parentXmlNode) {
            if (!xsdDoc) { alert(t('msg_load_xsd_first')); return; }
            currentNodeToModify = null;
            currentParentNode = parentXmlNode;
            
            const modal = document.getElementById('elementModal');
            const modalTitle = document.getElementById('modalTitle');
            const elementOptionsDiv = document.getElementById('elementOptions');
            const customInputSection = document.querySelector('.custom-input-section');
            const customElementName = document.getElementById('customElementName');
            const valueInputSection = document.getElementById('valueInputSection');
            const attributeInputs = document.getElementById('attributeInputs');
            const attributeOptionsDiv = document.getElementById('attributeOptions');
            const addBtn = modal.querySelector('.modal-btn.primary');
            
            modalTitle.textContent = t('modal_title_add');
            modal.dataset.mode = 'add';
            addBtn.textContent = t('btn_confirm');

            elementOptionsDiv.innerHTML = '';
            customElementName.value = '';
            valueInputSection.style.display = 'none';
            customInputSection.style.display = 'block';

            const parentName = parentXmlNode.nodeName;
            const parentDef = xsdElements.get(parentName);
            
            if (parentDef && parentDef.childElements && parentDef.childElements.length > 0) {
                parentDef.childElements.forEach(elem => {
                    const elemDef = xsdElements.get(elem.name);
                    const optionDiv = document.createElement('div');
                    optionDiv.className = 'element-option';
                    optionDiv.innerHTML = `
                        <div class="element-name">${elem.name}</div>
                        <div class="element-type">${(elemDef && elemDef.valueType) || t('opt_complex')}</div>
                        <div class="element-constraints">${elem.minOccurs || '1'}..${elem.maxOccurs || '1'}</div>
                    `;
                    optionDiv.onclick = () => selectElement(optionDiv, elem.name);
                    elementOptionsDiv.appendChild(optionDiv);
                });
            } else {
                elementOptionsDiv.innerHTML = `<p style="text-align: center; color: #9ca3af;">${t('no_child_defs')}</p>`;
            }

            attributeInputs.innerHTML = '';
            attributeOptionsDiv.innerHTML = '';
            addAttributeRow();
            modal.classList.add('show');
        }

        // Logic to edit a node / ç·¨è¼¯ç¯€é»é‚è¼¯
        function editNode(xmlNode) {
            if (!xsdDoc) { alert(t('msg_load_xsd_first')); return; }
            currentNodeToModify = xmlNode;
            
            const modal = document.getElementById('elementModal');
            const modalTitle = document.getElementById('modalTitle');
            const elementOptionsDiv = document.getElementById('elementOptions');
            const customInputSection = document.querySelector('.custom-input-section');
            const customElementName = document.getElementById('customElementName');
            const valueInputSection = document.getElementById('valueInputSection');
            
            // Get References
            const elementValueInput = document.getElementById('elementValueInput');
            const elementValueSelect = document.getElementById('elementValueSelect');
            const elementValueDate = document.getElementById('elementValueDate');
            const elementValueDateTime = document.getElementById('elementValueDateTime');
            const elementValueTime = document.getElementById('elementValueTime');

            const enumHint = document.getElementById('enumHint');
            const dateHint = document.getElementById('dateHint');
            const dateTimeHint = document.getElementById('dateTimeHint');
            const timeHint = document.getElementById('timeHint');

            const attributeInputs = document.getElementById('attributeInputs');
            const attributeOptionsDiv = document.getElementById('attributeOptions');
            const addBtn = modal.querySelector('.modal-btn.primary');

            modalTitle.textContent = t('modal_title_edit');
            modal.dataset.mode = 'edit';
            addBtn.textContent = t('btn_confirm');

            elementOptionsDiv.innerHTML = '';
            customInputSection.style.display = 'block';
            customElementName.value = xmlNode.nodeName;

            const elementDef = xsdElements.get(xmlNode.nodeName);
            if (elementDef && elementDef.valueType) {
                valueInputSection.style.display = 'block';
                
                // Reset Display
                elementValueInput.style.display = 'none';
                elementValueSelect.style.display = 'none';
                elementValueDate.style.display = 'none';
                elementValueDateTime.style.display = 'none';
                elementValueTime.style.display = 'none';
                
                enumHint.style.display = 'none';
                dateHint.style.display = 'none';
                dateTimeHint.style.display = 'none';
                timeHint.style.display = 'none';

                // Switch Input based on Type
                // 1. Enumeration
                if (elementDef.enumerations && elementDef.enumerations.length > 0) {
                    elementValueSelect.style.display = 'block';
                    enumHint.style.display = 'block';
                    elementValueSelect.innerHTML = `<option value="">${t('opt_select')}</option>` + 
                        elementDef.enumerations.map(val => `<option value="${val}">${val}</option>`).join('');
                    elementValueSelect.value = xmlNode.textContent;
                } 
                // 2. Date
                else if (elementDef.valueType === 'xs:date') {
                    elementValueDate.style.display = 'block';
                    dateHint.style.display = 'block';
                    elementValueDate.value = xmlNode.textContent;
                }
                // 3. DateTime
                else if (elementDef.valueType === 'xs:dateTime' || elementDef.valueType === 'ISODateTime') {
                    elementValueDateTime.style.display = 'block';
                    dateTimeHint.style.display = 'block';
                    elementValueDateTime.value = xmlNode.textContent;
                }
                // 4. Time
                else if (elementDef.valueType === 'xs:time' || elementDef.valueType === 'ISOTime') {
                    elementValueTime.style.display = 'block';
                    timeHint.style.display = 'block';
                    elementValueTime.value = xmlNode.textContent;
                }
                // 5. Default Text
                else {
                    elementValueInput.style.display = 'block';
                    elementValueInput.value = xmlNode.textContent;
                }
            } else {
                valueInputSection.style.display = 'none';
            }

            attributeInputs.innerHTML = '';
            attributeOptionsDiv.innerHTML = '';

            if (elementDef && elementDef.attributes.length > 0) {
                const title = document.createElement('h5');
                title.style.margin = '0 0 10px 0'; title.style.color = '#4b5563'; title.textContent = t('optional_attrs');
                attributeOptionsDiv.appendChild(title);
                elementDef.attributes.forEach(attr => {
                    const optionBtn = document.createElement('span');
                    optionBtn.className = `attribute-option ${attr.use === 'required' ? 'required' : ''}`;
                    optionBtn.textContent = attr.name;
                    optionBtn.onclick = () => addAttributeFromOption(attr.name);
                    attributeOptionsDiv.appendChild(optionBtn);
                });
            }

            Array.from(xmlNode.attributes).forEach(attr => {
                const newRow = document.createElement('div');
                newRow.className = 'attribute-row';
                newRow.innerHTML = `<input type="text" placeholder="${t('ph_attr_name')}" class="attr-name" value="${attr.name}"><input type="text" placeholder="${t('ph_attr_val')}" class="attr-value" value="${attr.value}"><button class="delete-btn" onclick="this.parentNode.remove()">${t('btn_delete')}</button>`;
                attributeInputs.appendChild(newRow);
            });
            addAttributeRow();
            modal.classList.add('show');
        }

        function selectElement(optionDiv, tagName) {
            const allOptions = document.querySelectorAll('.element-option');
            allOptions.forEach(opt => opt.classList.remove('selected'));
            optionDiv.classList.add('selected');
            document.getElementById('customElementName').value = tagName;

            const elementDef = xsdElements.get(tagName);
            const valueInputSection = document.getElementById('valueInputSection');
            const elementValueInput = document.getElementById('elementValueInput');
            const elementValueSelect = document.getElementById('elementValueSelect');
            const elementValueDate = document.getElementById('elementValueDate');
            const elementValueDateTime = document.getElementById('elementValueDateTime');
            const elementValueTime = document.getElementById('elementValueTime');

            const enumHint = document.getElementById('enumHint');
            const dateHint = document.getElementById('dateHint');
            const dateTimeHint = document.getElementById('dateTimeHint');
            const timeHint = document.getElementById('timeHint');

            if (elementDef && elementDef.valueType) {
                valueInputSection.style.display = 'block';
                
                elementValueInput.style.display = 'none';
                elementValueSelect.style.display = 'none';
                elementValueDate.style.display = 'none';
                elementValueDateTime.style.display = 'none';
                elementValueTime.style.display = 'none';

                enumHint.style.display = 'none';
                dateHint.style.display = 'none';
                dateTimeHint.style.display = 'none';
                timeHint.style.display = 'none';
                
                if (elementDef.enumerations && elementDef.enumerations.length > 0) {
                    elementValueSelect.style.display = 'block';
                    enumHint.style.display = 'block';
                    elementValueSelect.innerHTML = `<option value="">${t('opt_select')}</option>` + 
                        elementDef.enumerations.map(val => `<option value="${val}">${val}</option>`).join('');
                    elementValueSelect.value = '';
                } 
                else if (elementDef.valueType === 'xs:date') {
                    elementValueDate.style.display = 'block';
                    dateHint.style.display = 'block';
                    elementValueDate.value = '';
                }
                else if (elementDef.valueType === 'xs:dateTime' || elementDef.valueType === 'ISODateTime') {
                    elementValueDateTime.style.display = 'block';
                    dateTimeHint.style.display = 'block';
                    elementValueDateTime.value = '';
                }
                else if (elementDef.valueType === 'xs:time' || elementDef.valueType === 'ISOTime') {
                    elementValueTime.style.display = 'block';
                    timeHint.style.display = 'block';
                    elementValueTime.value = '';
                }
                else {
                    elementValueInput.style.display = 'block';
                    elementValueInput.value = '';
                }
            } else {
                valueInputSection.style.display = 'none';
            }
        }

        function addAttributeFromOption(attrName) {
            const attrInputs = document.querySelectorAll('#attributeInputs .attr-name');
            let exists = false;
            attrInputs.forEach(input => { if (input.value === attrName) exists = true; });

            if (!exists) {
                const newRow = document.createElement('div');
                newRow.className = 'attribute-row';
                newRow.innerHTML = `<input type="text" placeholder="${t('ph_attr_name')}" class="attr-name" value="${attrName}"><input type="text" placeholder="${t('ph_attr_val')}" class="attr-value"><button class="delete-btn" onclick="this.parentNode.remove()">${t('btn_delete')}</button>`;
                document.getElementById('attributeInputs').appendChild(newRow);
            }
        }

        function closeElementModal() {
            const modal = document.getElementById('elementModal');
            modal.classList.remove('show');
            document.querySelectorAll('.element-option').forEach(opt => opt.classList.remove('selected'));
            document.getElementById('customElementName').value = '';
            document.getElementById('elementValueInput').value = '';
            document.getElementById('elementValueSelect').innerHTML = ''; 
            document.getElementById('elementValueDate').value = '';
            document.getElementById('elementValueDateTime').value = '';
            document.getElementById('elementValueTime').value = ''; // Reset Time
            document.getElementById('attributeInputs').innerHTML = '';
            document.getElementById('attributeOptions').innerHTML = '';
            document.getElementById('valueInputSection').style.display = 'none';
            currentParentNode = null;
            currentNodeToModify = null;
        }

        function validateValue(value, type) {
            if (value === null || value === undefined || value.trim() === '') return true;
            switch (type) {
                case 'xs:int': case 'xs:integer': return !isNaN(parseInt(value)) && String(parseInt(value)) === value;
                case 'xs:decimal': case 'xs:float': case 'xs:double': return !isNaN(parseFloat(value));
                case 'xs:boolean': return value === 'true' || value === 'false' || value === '1' || value === '0';
                case 'xs:date': return !isNaN(new Date(value));
                case 'xs:dateTime': case 'ISODateTime': return !isNaN(Date.parse(value));
                case 'xs:time': case 'ISOTime': return /^([01]\d|2[0-3]):([0-5]\d)(:([0-5]\d))?(\.\d+)?(Z|[+-]\d{2}:\d{2})?$/.test(value);
                default: return true;
            }
        }

        function confirmAction() {
            const modal = document.getElementById('elementModal');
            const mode = modal.dataset.mode;
            const newName = document.getElementById('customElementName').value.trim();
            
            const elementDef = xsdElements.get(newName);
            let newValue = '';
            
            // Read Input Value
            if (elementDef && elementDef.enumerations && elementDef.enumerations.length > 0) {
                newValue = document.getElementById('elementValueSelect').value;
            } else if (elementDef && elementDef.valueType === 'xs:date') {
                newValue = document.getElementById('elementValueDate').value;
            } else if (elementDef && (elementDef.valueType === 'xs:dateTime' || elementDef.valueType === 'ISODateTime')) {
                newValue = document.getElementById('elementValueDateTime').value;
            } else if (elementDef && (elementDef.valueType === 'xs:time' || elementDef.valueType === 'ISOTime')) {
                newValue = document.getElementById('elementValueTime').value;
            } else {
                newValue = document.getElementById('elementValueInput').value.trim();
            }

            if (!newName) { alert(t('err_invalid_name')); return; }
            
            if (elementDef && elementDef.valueType && !validateValue(newValue, elementDef.valueType)) {
                alert(t('err_invalid_type') + `: ${elementDef.valueType}`); return;
            }

            const newAttrs = {};
            document.querySelectorAll('.attribute-row').forEach(row => {
                const attrName = row.querySelector('.attr-name').value.trim();
                const attrValue = row.querySelector('.attr-value').value.trim();
                if (attrName) newAttrs[attrName] = attrValue;
            });

            if (mode === 'add') {
                const newNode = xmlDoc.createElement(newName);
                for (const name in newAttrs) newNode.setAttribute(name, newAttrs[name]);
                if (elementDef && elementDef.valueType) newNode.textContent = newValue;
                currentParentNode.appendChild(newNode);
                updateStatus(t('val_updated'));
            } else if (mode === 'edit' && currentNodeToModify) {
                const oldName = currentNodeToModify.nodeName;
                if (oldName !== newName) {
                    const newElement = xmlDoc.createElement(newName);
                    while (currentNodeToModify.firstChild) newElement.appendChild(currentNodeToModify.firstChild);
                    currentNodeToModify.parentNode.replaceChild(newElement, currentNodeToModify);
                    currentNodeToModify = newElement;
                }
                Array.from(currentNodeToModify.attributes).forEach(attr => currentNodeToModify.removeAttribute(attr.name));
                for (const name in newAttrs) currentNodeToModify.setAttribute(name, newAttrs[name]);
                if (elementDef && elementDef.valueType) currentNodeToModify.textContent = newValue;
                updateStatus(t('val_updated'));
            }
            
            renderXMLTree();
            closeElementModal();
        }

        function addAttributeRow() {
            const attributeInputs = document.getElementById('attributeInputs');
            const newRow = document.createElement('div');
            newRow.className = 'attribute-row';
            newRow.innerHTML = `<input type="text" placeholder="${t('ph_attr_name')}" class="attr-name"><input type="text" placeholder="${t('ph_attr_val')}" class="attr-value"><button class="delete-btn" onclick="this.parentNode.remove()">${t('btn_delete')}</button>`;
            attributeInputs.appendChild(newRow);
        }

        function deleteNode(xmlNode, nodeDiv) {
            if (confirm(t('confirm_del'))) {
                xmlNode.parentNode.removeChild(xmlNode);
                nodeDiv.remove();
                updateNodeCount();
                updateStatus(t('node_deleted'));
            }
        }

        function validateXML() {
            if (!xsdDoc || !xmlDoc) { alert(t('msg_load_xsd_first')); return; }
            const resultDiv = document.getElementById('validationResult');
            resultDiv.innerHTML = `<div class="loading"></div> ${t('validating')}`;
            
            setTimeout(() => {
                const validationErrors = performDetailedValidation();
                if (validationErrors.length === 0) {
                    resultDiv.innerHTML = `<div class="validation-result valid">${t('valid_pass')}<div style="margin-top: 10px; font-size: 0.9em; opacity: 0.9;">${t('valid_pass_desc')}</div></div>`;
                } else {
                    resultDiv.innerHTML = `<div class="validation-result invalid">${t('valid_fail')}<div style="margin-top: 15px; font-size: 0.9em;">${t('valid_fail_desc')}<ul style="margin: 10px 0; padding-left: 20px;">${validationErrors.map(error => `<li>${error}</li>`).join('')}</ul></div></div>`;
                }
            }, 500);
        }

        function performDetailedValidation() {
            const errors = [];
            const rootName = xmlDoc.documentElement.nodeName;
            if (!xsdElements.has(rootName)) { errors.push(`${t('root_err')}: "${rootName}"`); return errors; }
            validateElement(xmlDoc.documentElement, rootName, errors);
            return errors;
        }

        function validateElement(xmlElement, expectedName, errors) {
            const elementDef = xsdElements.get(expectedName);
            if (!elementDef) return;
            
            if (elementDef.attributes) {
                elementDef.attributes.forEach(attr => {
                    if (attr.use === 'required' && !xmlElement.hasAttribute(attr.name)) errors.push(`${t('missing_attr')}: "${attr.name}" @ <${expectedName}>`);
                });
            }
            
            if (elementDef.valueType) {
                const val = xmlElement.textContent;
                if (!validateValue(val, elementDef.valueType)) errors.push(`${t('type_err')} "${elementDef.valueType}": "${val}" @ <${expectedName}>`);
                
                if (elementDef.enumerations && elementDef.enumerations.length > 0 && val.trim() !== '') {
                    if (!elementDef.enumerations.includes(val)) errors.push(`${t('enum_err')}: "${val}" @ <${expectedName}>`);
                }
            }

            if (elementDef.hasChildren) {
                const requiredChildren = elementDef.childElements.filter(child => child.minOccurs !== '0');
                requiredChildren.forEach(requiredChild => {
                    const childNodes = Array.from(xmlElement.children).filter(child => child.nodeName === requiredChild.name);
                    if (childNodes.length === 0) errors.push(`${t('missing_child')}: "${requiredChild.name}" @ <${expectedName}>`);
                    if (requiredChild.maxOccurs !== 'unbounded') {
                        const maxOccurs = parseInt(requiredChild.maxOccurs);
                        if (childNodes.length > maxOccurs) errors.push(`${t('max_occurs_err')}: "${requiredChild.name}" (Max: ${maxOccurs})`);
                    }
                });
                Array.from(xmlElement.children).forEach(child => {
                    const childDef = elementDef.childElements.find(ce => ce.name === child.nodeName);
                    if (!childDef && !xsdElements.has(child.nodeName)) errors.push(`${t('invalid_child')}: "${child.nodeName}" @ <${expectedName}>`);
                    validateElement(child, child.nodeName, errors);
                });
            }
        }

        function exportXML() {
            if (!xmlDoc) { alert(t('no_xml_export')); return; }
            const blob = new Blob([getXmlString()], { type: 'text/xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = 'document.xml'; a.click();
            URL.revokeObjectURL(url);
            updateStatus(t('xml_exported'));
        }

        function clearAll() {
            if (confirm(t('confirm_clear'))) {
                xsdDoc = null; xmlDoc = null; xsdElements.clear();
                document.getElementById('treeView').innerHTML = `<p style="color: #9ca3af; text-align: center; padding: 50px;">${t('msg_load_xsd_first')}</p>`;
                xmlRawInput.value = ''; updateSyntaxHighlighting();
                document.getElementById('schemaInfo').innerHTML = `<p>${t('msg_no_schema')}</p>`;
                document.getElementById('validationResult').innerHTML = '';
                document.getElementById('validateBtn').disabled = true;
                document.getElementById('xsdFile').value = '';
                updateNodeCount(); updateStatus(t('cleared'));
            }
        }

        function updateStatus(message) {
            document.getElementById('statusText').textContent = message;
            setTimeout(() => { document.getElementById('statusText').textContent = t('status_ready'); }, 3000);
        }

        function updateNodeCount() {
            const count = xmlDoc ? xmlDoc.getElementsByTagName('*').length : 0;
            document.getElementById('nodeCount').textContent = `${t('status_nodes').split(':')[0]}: ${count}`;
        }

        document.addEventListener('keydown', function(e) {
            if ((e.ctrlKey || e.metaKey) && e.key === 's') { e.preventDefault(); if (xmlDoc) exportXML(); }
            if ((e.ctrlKey || e.metaKey) && e.key === 'v') { e.preventDefault(); if (!document.getElementById('validateBtn').disabled) validateXML(); }
            if (e.key === 'Escape') {
                const modal = document.getElementById('elementModal');
                if (modal.classList.contains('show')) closeElementModal();
            }
        });
        window.onclick = function(event) {
            const modal = document.getElementById('elementModal');
            if (event.target === modal) closeElementModal();
        };
    </script>
</body>
</html>
